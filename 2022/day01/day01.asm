; w65c02 assembly code for 'day01'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2025-10-29T13:37:23
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=BASICSAFE

.cpu  'w65c02'
.enc  'none'
P8ZP_SCRATCH_B1 = 122
P8ZP_SCRATCH_REG = 123
P8ZP_SCRATCH_W1 = 124    ; word
P8ZP_SCRATCH_W2 = 126    ; word
P8ZP_SCRATCH_PTR = 34  ; word
.weak
.endweak
; ---- basic program with sys call ----
* = $0801
prog8_program_start	; start of program label
	.word  (+), 2025
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint
	cld
	tsx  ; save stackpointer for sys.exit()
	stx  prog8_lib.orig_stackpointer
	jsr  p8_sys_startup.init_system
	jsr  p8_sys_startup.init_system_phase2
	lda  #4
	sta  $01
	jsr  p8b_main.p8s_start
	jmp  p8_sys_startup.cleanup_at_exit

; ---- block: 'p8b_main' ----
p8b_main	.proc
	; source: day01.p8:33   main {


	; source: day01.p8:34   sub start() {

p8s_start	.proc
p8v_ok 	= 36 	; zp bool
p8v_line_count 	= 37 	; zp uword
p8v_line 	= 39 	; zp uword
p8v_i 	= 41 	; zp ubyte
p8v_done 	= 42 	; zp bool
	jsr  prog8_lib.program_startup_clear_bss
	jsr  p8b_lines.prog8_init_vars
	jsr  diskio.prog8_init_vars
+
; statements
	; source: day01.p8:35   bool ok
	; source: day01.p8:36   bool done
	; source: day01.p8:37   ubyte[80] filename
	; source: day01.p8:38   uword line
	; source: day01.p8:40   ubyte i
	; source: day01.p8:41   float cur_snack
	; source: day01.p8:42   float cur_total
	; source: day01.p8:43   float top_total
	; source: day01.p8:44   float[3] maxima = [0, 0, 0]
	; source: day01.p8:45   uword line_count = 0
	; source: day01.p8:35   bool ok
	stz  p8v_ok
	; source: day01.p8:36   bool done
	stz  p8v_done
	; source: day01.p8:38   uword line
	stz  p8v_line
	stz  p8v_line+1
	; source: day01.p8:40   ubyte i
	stz  p8v_i
	; source: day01.p8:41   float cur_snack
	stz  p8v_cur_snack
	stz  p8v_cur_snack+1
	stz  p8v_cur_snack+2
	stz  p8v_cur_snack+3
	stz  p8v_cur_snack+4
	; source: day01.p8:42   float cur_total
	stz  p8v_cur_total
	stz  p8v_cur_total+1
	stz  p8v_cur_total+2
	stz  p8v_cur_total+3
	stz  p8v_cur_total+4
	; source: day01.p8:43   float top_total
	stz  p8v_top_total
	stz  p8v_top_total+1
	stz  p8v_top_total+2
	stz  p8v_top_total+3
	stz  p8v_top_total+4
	; source: day01.p8:45   uword line_count = 0
	stz  p8v_line_count
	stz  p8v_line_count+1
	; source: day01.p8:47   repeat {
p8_label_gen_7_repeat
	; source: day01.p8:48   ok = false
	stz  p8v_ok
	; source: day01.p8:49   while not ok {
p8_label_gen_1_whileloop
	lda  p8v_ok
	bne  p8_label_gen_2_afterwhile
	; source: day01.p8:50   txt.print("filename:")
	ldy  #>prog8_interned_strings.string_1
	lda  #<prog8_interned_strings.string_1
	jsr  txt.print
	; source: day01.p8:51   void txt.input_chars(&filename)
	ldy  #>p8v_filename
	lda  #<p8v_filename
	jsr  txt.input_chars
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: day01.p8:53   if strings.length(filename) < 2 {
	ldy  #>p8v_filename
	lda  #<p8v_filename
	jsr  strings.length
	tya
	cmp  #2
	bcs  p8_label_gen_61_afterif
	; source: day01.p8:54   txt.print("never mind.")
	ldy  #>prog8_interned_strings.string_2
	lda  #<prog8_interned_strings.string_2
	jsr  txt.print
	; source: day01.p8:55   sys.exit(0)
	lda  #0
	jsr  sys.exit
p8_label_gen_61_afterif
	; source: day01.p8:57   ok = diskio.f_open(filename)
	ldy  #>p8v_filename
	lda  #<p8v_filename
	jsr  diskio.f_open
	sta  p8v_ok
	; source: day01.p8:49   while not ok {
	bra  p8_label_gen_1_whileloop
p8_label_gen_2_afterwhile
	; source: day01.p8:59   txt.chrout(0)
	lda  #0
	jsr  txt.chrout
	; source: day01.p8:61   cur_total = 0.0
	stz  p8v_cur_total
	stz  p8v_cur_total+1
	stz  p8v_cur_total+2
	stz  p8v_cur_total+3
	stz  p8v_cur_total+4
	; source: day01.p8:62   for i in 0 to 2 {
	lda  #0
	sta  p8v_i
p8_label_gen_62_for_loop
	; source: day01.p8:63   maxima[i] = 0.0
	lda  p8v_i
	ldy  #<p8v_maxima
	sty  P8ZP_SCRATCH_W1
	ldy  #>p8v_maxima
	sty  P8ZP_SCRATCH_W1+1
	jsr  floats.set_0_array_float
	inc  p8v_i
	lda  p8v_i
	cmp  #3
	bne  p8_label_gen_62_for_loop
p8_label_gen_63_for_end
	; source: day01.p8:65   done = false
	stz  p8v_done
	; source: day01.p8:66   line_count = 0
	stz  p8v_line_count
	stz  p8v_line_count+1
	; source: day01.p8:68   while not done {
p8_label_gen_5_whileloop
	lda  p8v_done
	bne  p8_label_gen_6_afterwhile
	; source: day01.p8:69   txt.chrout(0)
	lda  #0
	jsr  txt.chrout
	; source: day01.p8:70   line = lines.readline()
	jsr  p8b_lines.p8s_readline
	sta  p8v_line
	sty  p8v_line+1
	; source: day01.p8:71   i = 0
	stz  p8v_i
	; source: day01.p8:72   if line == lines.nil {
	lda  p8v_line
	ora  p8v_line+1
	bne  p8_label_gen_65_else
	; source: day01.p8:73   done = true
	lda  #1
	sta  p8v_done
	bra  p8_label_gen_64_afterif
p8_label_gen_65_else
	; source: day01.p8:75   line_count += 1
	inc  p8v_line_count
	bne  +
	inc  p8v_line_count+1
+
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: day01.p8:79   cur_snack = 0
	stz  p8v_cur_snack
	stz  p8v_cur_snack+1
	stz  p8v_cur_snack+2
	stz  p8v_cur_snack+3
	stz  p8v_cur_snack+4
	; source: day01.p8:80   while line[i] != 0 {
p8_label_gen_3_whileloop
	ldy  p8v_i
	lda  (p8v_line),y
	beq  p8_label_gen_4_afterwhile
	; source: day01.p8:81   if line[i] >= '0' and line[i] <= '9' {
	ldy  p8v_i
	lda  (p8v_line),y
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_66_shortcut
	ldy  p8v_i
	lda  (p8v_line),y
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_66_shortcut
	beq  p8_label_gen_67_afterif
	; source: day01.p8:82   cur_snack = cur_snack * 10 + (line[i] - '0') as float
	lda  #<p8v_cur_snack
	ldy  #>p8v_cur_snack
	jsr  floats.MOVFM
	lda  #<prog8_float_const_0
	ldy  #>prog8_float_const_0
	jsr  floats.CONUPK
	jsr  floats.FMULTT
	jsr  floats.pushFAC1
	jsr  floats.pushFAC1
	ldy  p8v_i
	lda  (p8v_line),y
	sec
	sbc  #$30
	tay
	jsr  floats.FREADUY
	jsr  floats.MOVEF
	clc
	jsr  floats.popFAC
	clc
	jsr  floats.popFAC
	jsr  floats.FADDT
	ldx  #<p8v_cur_snack
	ldy  #>p8v_cur_snack
	jsr  floats.MOVMF
p8_label_gen_67_afterif
	; source: day01.p8:84   i=i+1
	inc  p8v_i
	; source: day01.p8:80   while line[i] != 0 {
	bra  p8_label_gen_3_whileloop
p8_label_gen_4_afterwhile
p8_label_gen_64_afterif
	; source: day01.p8:87   if i==0 {
	lda  p8v_i
	bne  p8_label_gen_69_else
	; source: day01.p8:88   if cur_total > maxima[2] {
	lda  #<(p8v_maxima+10)
	ldy  #>(p8v_maxima+10)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	jsr  floats.copy_float
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	lda  #<p8v_cur_total
	ldy  #>p8v_cur_total
jsr  floats.vars_lesseq_f
	bne  p8_label_gen_70_afterif
	; source: day01.p8:89   maxima[2] = cur_total
	lda  #2
	ldy  #<p8v_cur_total
	sty  P8ZP_SCRATCH_W1
	ldy  #>p8v_cur_total
	sty  P8ZP_SCRATCH_W1+1
	ldy  #<p8v_maxima
	sty  P8ZP_SCRATCH_W2
	ldy  #>p8v_maxima
	sty  P8ZP_SCRATCH_W2+1
	jsr  floats.set_array_float
	; source: day01.p8:90   if cur_total > maxima[1] {
	lda  #<(p8v_maxima+5)
	ldy  #>(p8v_maxima+5)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	jsr  floats.copy_float
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	lda  #<p8v_cur_total
	ldy  #>p8v_cur_total
jsr  floats.vars_lesseq_f
	bne  p8_label_gen_71_afterif
	; source: day01.p8:91   maxima[2] = maxima[1]
	lda  #<(p8v_maxima+5)
	ldy  #>(p8v_maxima+5)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<p8v_maxima
	ldy  #>p8v_maxima
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	jsr  floats.set_array_float
	; source: day01.p8:92   maxima[1] = cur_total
	lda  #1
	ldy  #<p8v_cur_total
	sty  P8ZP_SCRATCH_W1
	ldy  #>p8v_cur_total
	sty  P8ZP_SCRATCH_W1+1
	ldy  #<p8v_maxima
	sty  P8ZP_SCRATCH_W2
	ldy  #>p8v_maxima
	sty  P8ZP_SCRATCH_W2+1
	jsr  floats.set_array_float
	; source: day01.p8:93   if cur_total > maxima[0] {
	lda  #<(p8v_maxima+0)
	ldy  #>(p8v_maxima+0)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	jsr  floats.copy_float
	lda  #<prog8_float_eval_result1
	ldy  #>prog8_float_eval_result1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	lda  #<p8v_cur_total
	ldy  #>p8v_cur_total
jsr  floats.vars_lesseq_f
	bne  p8_label_gen_72_afterif
	; source: day01.p8:94   maxima[1] = maxima[0]
	lda  #<(p8v_maxima+0)
	ldy  #>(p8v_maxima+0)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<p8v_maxima
	ldy  #>p8v_maxima
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	jsr  floats.set_array_float
	; source: day01.p8:95   maxima[0] = cur_total
	lda  #0
	ldy  #<p8v_cur_total
	sty  P8ZP_SCRATCH_W1
	ldy  #>p8v_cur_total
	sty  P8ZP_SCRATCH_W1+1
	ldy  #<p8v_maxima
	sty  P8ZP_SCRATCH_W2
	ldy  #>p8v_maxima
	sty  P8ZP_SCRATCH_W2+1
	jsr  floats.set_array_float
p8_label_gen_72_afterif
p8_label_gen_71_afterif
p8_label_gen_70_afterif
	; source: day01.p8:99   cur_total = 0
	stz  p8v_cur_total
	stz  p8v_cur_total+1
	stz  p8v_cur_total+2
	stz  p8v_cur_total+3
	stz  p8v_cur_total+4
	bra  p8_label_gen_68_afterif
p8_label_gen_69_else
	; source: day01.p8:101   cur_total += cur_snack
	lda  #<p8v_cur_total
	ldy  #>p8v_cur_total
	jsr  floats.MOVFM
	lda  #<p8v_cur_snack
	ldy  #>p8v_cur_snack
	jsr  floats.FADD
	ldx  #<p8v_cur_total
	ldy  #>p8v_cur_total
	jsr  floats.MOVMF
p8_label_gen_68_afterif
	; source: day01.p8:68   while not done {
	bra  p8_label_gen_5_whileloop
p8_label_gen_6_afterwhile
	; source: day01.p8:104   diskio.f_close()
	jsr  diskio.f_close
	; source: day01.p8:105   txt.print("read ")
	ldy  #>prog8_interned_strings.string_3
	lda  #<prog8_interned_strings.string_3
	jsr  txt.print
	; source: day01.p8:106   txt.print_uw(line_count-1)
	ldy  p8v_line_count+1
	lda  p8v_line_count
	dec  a
	cmp  #255
	bne  +
	dey
+
	jsr  txt.print_uw
	; source: day01.p8:107   txt.print(" lines")
	ldy  #>prog8_interned_strings.string_4
	lda  #<prog8_interned_strings.string_4
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: day01.p8:109   txt.print("highest total:")
	ldy  #>prog8_interned_strings.string_5
	lda  #<prog8_interned_strings.string_5
	jsr  txt.print
	; source: day01.p8:110   txt.print_f(maxima[0])
	lda  #<(p8v_maxima+0)
	ldy  #>(p8v_maxima+0)
	jsr  floats.MOVFM
	jsr  floats.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: day01.p8:112   txt.print_f(maxima[0])
	lda  #<(p8v_maxima+0)
	ldy  #>(p8v_maxima+0)
	jsr  floats.MOVFM
	jsr  floats.print
	; source: day01.p8:113   top_total = maxima[0]
	lda  #<(p8v_maxima+0)
	ldy  #>(p8v_maxima+0)
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  #<p8v_top_total
	ldy  #>p8v_top_total
	jsr  floats.copy_float
	; source: day01.p8:114   for i in 1 to 2 {
	lda  #1
	sta  p8v_i
p8_label_gen_73_for_loop
	; source: day01.p8:115   txt.chrout('+')
	lda  #$2b
	jsr  txt.chrout
	; source: day01.p8:116   txt.print_f(maxima[i])
	lda  p8v_i
	sta  P8ZP_SCRATCH_REG
	asl  a
	asl  a
	clc
	adc  P8ZP_SCRATCH_REG
	ldy  #>p8v_maxima
	clc
	adc  #<p8v_maxima
	bcc  +
	iny
+
	jsr  floats.MOVFM
	jsr  floats.print
	; source: day01.p8:117   top_total += maxima[i]
	lda  p8v_i
	sta  P8ZP_SCRATCH_REG
	asl  a
	asl  a
	clc
	adc  P8ZP_SCRATCH_REG
	ldy  #>p8v_maxima
	clc
	adc  #<p8v_maxima
	bcc  +
	iny
+
	jsr  floats.MOVFM
	lda  #<p8v_top_total
	ldy  #>p8v_top_total
	jsr  floats.FADD
	ldx  #<p8v_top_total
	ldy  #>p8v_top_total
	jsr  floats.MOVMF
	inc  p8v_i
	lda  p8v_i
	cmp  #3
	bne  p8_label_gen_73_for_loop
p8_label_gen_74_for_end
	; source: day01.p8:119   txt.chrout('=')
	lda  #$3d
	jsr  txt.chrout
	; source: day01.p8:121   txt.print_f(top_total)
	lda  #<p8v_top_total
	ldy  #>p8v_top_total
	jsr  floats.MOVFM
	jsr  floats.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: day01.p8:47   repeat {
	bra  p8_label_gen_7_repeat
	; source: day01.p8:34   sub start() {
	rts
; variables
	.section BSS_NOCLEAR
prog8_float_eval_result1    .fill  5
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_cur_snack	.fill  5
p8v_cur_total	.fill  5
p8v_filename	.fill  80
p8v_top_total	.fill  5
	.send BSS
; non-zeropage variables with init value
p8v_maxima
	.byte  $00, $00, $00, $00, $00  ; float prog8.code.StArrayElement@3f06ebe0
	.byte  $00, $00, $00, $00, $00  ; float prog8.code.StArrayElement@1752e45c
	.byte  $00, $00, $00, $00, $00  ; float prog8.code.StArrayElement@5ed65e4b
	.pend
	.pend

; ---- block: 'p8_sys_startup' ----
p8_sys_startup	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2187   p8_sys_startup {


	; source: library:/prog8lib/cx16/syslib.p8:2190   asmsub  init_system()  {

init_system	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2193   %asm {{
        sei
        lda  #0
        tax
        tay
        jsr  cx16.mouse_config  ; disable mouse
        lda  cx16.VERA_DC_VIDEO
        and  #%00000111 ; retain chroma + output mode
        sta  P8ZP_SCRATCH_REG
        lda  #$0a
        sta  $01        ; rom bank 10 (audio)
        jsr  cx16.audio_init ; silence
        stz  $01        ; rom bank 0 (kernal)
        jsr  cbm.IOINIT
        jsr  cbm.RESTOR
        jsr  cbm.CINT
        lda  cx16.VERA_DC_VIDEO
        and  #%11111000
        ora  P8ZP_SCRATCH_REG
        sta  cx16.VERA_DC_VIDEO  ; restore old output mode
        lda  #$90       ; black
        jsr  cbm.CHROUT
        lda  #1
        jsr  cbm.CHROUT ; swap fg/bg
        lda  #$9e       ; yellow
        jsr  cbm.CHROUT
        lda  #147       ; clear screen
        jsr  cbm.CHROUT
        lda  #8         ; disable charset case switch
        jsr  cbm.CHROUT
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        lda  #0
        sta  $01    ; set ROM bank to kernal bank to speed up kernal calls
        tax
        tay
        cli
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2234   asmsub  init_system_phase2()  {

init_system_phase2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2235   %asm {{
        sei
        lda  cbm.CINV
        sta  sys.restore_irq._orig_irqvec
        lda  cbm.CINV+1
        sta  sys.restore_irq._orig_irqvec+1
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        stz  $01    ; set ROM bank to kernal bank to speed up kernal calls
        cli
        cld
        clc
        clv
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2252   asmsub  cleanup_at_exit() {

cleanup_at_exit	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2254   %asm {{
        lda  #1
        sta  $00        ; ram bank 1
        lda  #4
        sta  $01        ; rom bank 4 (basic)
        jsr  cbm.CLRCHN		; reset i/o channels
        lda  #9
        jsr  cbm.CHROUT     ; enable charset switch
        lda  _exitcarry
        lsr  a
        lda  _exitcode
        ldx  _exitcodeX
        ldy  _exitcodeY
        rts

        .section BSS
_exitcarry  .byte ?
_exitcode   .byte ?
_exitcodeX  .byte ?
_exitcodeY  .byte ?
        .send BSS

        ; !notreached!
	.pend
	.pend

; ---- block: 'p8b_lines' ----
p8b_lines	.proc
	; source: day01.p8:8   lines {
p8v_status 	= 43 	; zp ubyte
p8v_length 	= 44 	; zp ubyte
p8v_eof 	= 45 	; zp bool
	p8c_nil = 0

; non-zeropage variables
	.section BSS
p8v_buffer	.fill  256
	.send BSS

	; source: day01.p8:11   const uword nil = $0000
	; source: day01.p8:12   ubyte[256] buffer
	; source: day01.p8:13   bool eof = false
	; source: day01.p8:14   ubyte length, status
	; source: day01.p8:16   sub readline() -> ^^ubyte {

p8s_readline	.proc
; statements
	; source: day01.p8:17   if eof {
	lda  p8b_lines.p8v_eof
	beq  p8_label_gen_75_afterif
	; source: day01.p8:18   eof = false
	stz  p8b_lines.p8v_eof
	; source: day01.p8:19   return nil
	lda  #0
	tay
	rts
p8_label_gen_75_afterif
	; source: day01.p8:21   length, status = diskio.f_readline(buffer)
	ldy  #>p8b_lines.p8v_buffer
	lda  #<p8b_lines.p8v_buffer
	jsr  diskio.f_readline
	sty  p8b_lines.p8v_length
	sta  p8b_lines.p8v_status
	; source: day01.p8:22   if (status & 64) != 0 {
	bit  p8b_lines.p8v_status
	bvc  p8_label_gen_77_else
	; source: day01.p8:23   eof = true
	lda  #1
	sta  p8b_lines.p8v_eof
	bra  p8_label_gen_76_afterif
p8_label_gen_77_else
	; source: day01.p8:24   } else if status != 0 {
	lda  p8b_lines.p8v_status
	beq  p8_label_gen_78_afterif
	; source: day01.p8:27   return nil
	lda  #0
	tay
	rts
p8_label_gen_78_afterif
p8_label_gen_76_afterif
	; source: day01.p8:29   return &buffer
	ldy  #>p8b_lines.p8v_buffer
	lda  #<p8b_lines.p8v_buffer
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
prog8_init_vars	.block
	; source: day01.p8:13   bool eof = false
	stz  p8b_lines.p8v_eof
	; source: day01.p8:14   ubyte length, status
	stz  p8b_lines.p8v_length
	stz  p8b_lines.p8v_status
	rts
	.bend
	.pend

; ---- block: 'prog8_interned_strings' ----
prog8_interned_strings	.proc

; non-zeropage variables with init value
string_1	; PETSCII:"filename:"
	.byte  $46, $49, $4c, $45, $4e, $41, $4d, $45, $3a, $00
string_2	; PETSCII:"never mind."
	.byte  $4e, $45, $56, $45, $52, $20, $4d, $49, $4e, $44, $2e, $00
string_3	; PETSCII:"read "
	.byte  $52, $45, $41, $44, $20, $00
string_4	; PETSCII:" lines"
	.byte  $20, $4c, $49, $4e, $45, $53, $00
string_5	; PETSCII:"highest total:"
	.byte  $48, $49, $47, $48, $45, $53, $54, $20, $54, $4f, $54, $41, $4c, $3a, $00

	; source: day01.p8:50   txt.print("filename:")
	; source: day01.p8:54   txt.print("never mind.")
	; source: day01.p8:105   txt.print("read ")
	; source: day01.p8:107   txt.print(" lines")
	; source: day01.p8:109   txt.print("highest total:")
	.pend

; ---- block: 'diskio' ----
diskio	.proc
	; source: library:/prog8lib/cx16/diskio.p8:23   diskio {
iteration_in_progress 	= 46 	; zp bool
drivenumber 	= 49 	; zp ubyte
	READ_IO_CHANNEL = 12
	STATUS_EOF = $40
	WRITE_IO_CHANNEL = 13


	; source: library:/prog8lib/cx16/diskio.p8:26   const ubyte READ_IO_CHANNEL=12
	; source: library:/prog8lib/cx16/diskio.p8:27   const ubyte WRITE_IO_CHANNEL=13
	; source: library:/prog8lib/cx16/diskio.p8:28   const ubyte STATUS_EOF=$40
	; source: library:/prog8lib/cx16/diskio.p8:30   ubyte @shared drivenumber = 8           ; user programs can set this to the drive number they want to load/save to!
	; source: library:/prog8lib/cx16/diskio.p8:170   bool iteration_in_progress = false
	; source: library:/prog8lib/cx16/diskio.p8:24   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/cx16/diskio.p8:32   sub reset_read_channel() {

reset_read_channel	.proc
; statements
	; source: library:/prog8lib/cx16/diskio.p8:33   void cbm.CHKIN(READ_IO_CHANNEL)
	ldx  #12
	jmp  cbm.CHKIN
	; source: library:/prog8lib/cx16/diskio.p8:32   sub reset_read_channel() {
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/cx16/diskio.p8:337   sub f_open(str filenameptr) -> bool {

f_open	.proc
filenameptr 	= 47 	; zp ^^ubyte
; simple int arg(s) passed via cpu register(s)
	sta  filenameptr
	sty  filenameptr+1
; statements
	; source: library:/prog8lib/cx16/diskio.p8:344   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/cx16/diskio.p8:346   cbm.SETNAM(strings.length(filenameptr), filenameptr)
	ldy  filenameptr+1
	ldx  filenameptr
	phx
	phy
	ldy  filenameptr+1
	lda  filenameptr
	jsr  strings.length
	tya
	ply
	plx
	jsr  cbm.SETNAM
	; source: library:/prog8lib/cx16/diskio.p8:347   cbm.SETLFS(READ_IO_CHANNEL, drivenumber, READ_IO_CHANNEL)     ; note: has to be Channel,x,Channel because otherwise f_seek doesn't work
	ldy  #12
	ldx  diskio.drivenumber
	lda  #12
	jsr  cbm.SETLFS
	; source: library:/prog8lib/cx16/diskio.p8:348   void cbm.OPEN()          ; open 12,8,12,"filename"
	jsr  cbm.OPEN
	; source: library:/prog8lib/cx16/diskio.p8:349   if_cc {
	bcs  p8_label_gen_79_branch_else
	; source: library:/prog8lib/cx16/diskio.p8:33   void cbm.CHKIN(READ_IO_CHANNEL)
	ldx  #12
	jsr  cbm.CHKIN
	; source: library:/prog8lib/cx16/diskio.p8:351   if cbm.READST()==0 {
	jsr  cbm.READST
	cmp  #0
	bne  p8_label_gen_80_afterif
	; source: library:/prog8lib/cx16/diskio.p8:352   iteration_in_progress = true
	lda  #1
	sta  diskio.iteration_in_progress
	; source: library:/prog8lib/cx16/diskio.p8:353   void cbm.CHRIN()        ; read first byte to test for file not found
	jsr  cbm.CHRIN
	; source: library:/prog8lib/cx16/diskio.p8:354   if cbm.READST() & ~STATUS_EOF == 0 {
	jsr  cbm.READST
	and  #$bf
	bne  p8_label_gen_81_afterif
	; source: library:/prog8lib/cx16/diskio.p8:355   cbm.CLOSE(READ_IO_CHANNEL)    ; close file because we already consumed first byte
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/cx16/diskio.p8:356   void cbm.OPEN()         ; re-open the file
	jsr  cbm.OPEN
	; source: library:/prog8lib/cx16/diskio.p8:357   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/cx16/diskio.p8:358   return true
	lda  #1
	rts
p8_label_gen_81_afterif
p8_label_gen_80_afterif
p8_label_gen_79_branch_else
	; source: library:/prog8lib/cx16/diskio.p8:362   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/cx16/diskio.p8:363   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/cx16/diskio.p8:364   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/cx16/diskio.p8:463   asmsub f_readline(^^ubyte bufptr @AY) clobbers(X) -> ubyte @Y, ubyte @A {

f_readline	.proc
	; source: library:/prog8lib/cx16/diskio.p8:469   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            jsr  reset_read_channel
            ldy  #0
_loop       jsr  cbm.CHRIN
            sta  (P8ZP_SCRATCH_W1),y
            beq  _end
            iny
            cmp  #$0a
            beq  _line_end
            cmp  #$0d
            bne  _loop
_line_end   dey     ; get rid of the trailing end-of-line char
            lda  #0
            sta  (P8ZP_SCRATCH_W1),y
_end        jsr  cbm.READST
            pha
            phy
            jsr  cbm.CLRCHN
            ply
            pla
            rts
	.pend
	; source: library:/prog8lib/cx16/diskio.p8:495   sub f_close() {

f_close	.proc
; statements
	; source: library:/prog8lib/cx16/diskio.p8:498   if iteration_in_progress {
	lda  diskio.iteration_in_progress
	beq  p8_label_gen_82_afterif
	; source: library:/prog8lib/cx16/diskio.p8:499   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/cx16/diskio.p8:500   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/cx16/diskio.p8:501   iteration_in_progress = false
	stz  diskio.iteration_in_progress
p8_label_gen_82_afterif
	; source: library:/prog8lib/cx16/diskio.p8:495   sub f_close() {
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/cx16/diskio.p8:830   asmsub vload(str name @R0, ubyte bank @A, uword startaddress @R1) clobbers(X, Y) -> bool @A {

vload	.proc
	; source: library:/prog8lib/cx16/diskio.p8:834   %asm {{
            clc
internal_vload:
            pha
            ldx  drivenumber
            bcc +
            ldy  #%00000010     ; headerless load mode
            bne  ++
+           ldy  #0             ; normal load mode
+           lda  #1
            jsr  cbm.SETLFS
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  prog8_lib.strlen
            tya
            ldx  cx16.r0
            ldy  cx16.r0+1
            jsr  cbm.SETNAM
            pla
            clc
            adc  #2
            ldx  cx16.r1
            ldy  cx16.r1+1
            stz  P8ZP_SCRATCH_B1
            jsr  cbm.LOAD
            bcs  +
            inc  P8ZP_SCRATCH_B1
    +       jsr  cbm.CLRCHN
            lda  #1
            jsr  cbm.CLOSE
            lda  P8ZP_SCRATCH_B1
            rts
	.pend
	; source: library:/prog8lib/cx16/diskio.p8:869   asmsub vload_raw(str name @R0, ubyte bank @A, uword startaddress @R1) clobbers(X, Y) -> bool @A {

vload_raw	.proc
	; source: library:/prog8lib/cx16/diskio.p8:873   %asm {{
            sec
            jmp  vload.internal_vload
	.pend
	; source: library:/prog8lib/cx16/diskio.p8:1033   asmsub f_tell() -> uword @R0, uword @R1, uword @R2, uword @R3 {

f_tell	.proc
	; source: library:/prog8lib/cx16/diskio.p8:1037   %asm {{
            jmp  internal_f_tell
	.pend
prog8_init_vars	.block
	; source: library:/prog8lib/cx16/diskio.p8:30   ubyte @shared drivenumber = 8           ; user programs can set this to the drive number they want to load/save to!
	lda  #8
	sta  diskio.drivenumber
	; source: library:/prog8lib/cx16/diskio.p8:170   bool iteration_in_progress = false
	stz  diskio.iteration_in_progress
	rts
	.bend
	.pend

; ---- block: 'txt' ----
txt	.proc
	; source: library:/prog8lib/cx16/textio.p8:9   txt {
	DEFAULT_HEIGHT = $3c
	DEFAULT_WIDTH = $50
	VERA_TEXTMATRIX = $0001b000

	chrout = $ffd2

	; source: library:/prog8lib/cx16/textio.p8:13   const ubyte DEFAULT_WIDTH = 80
	; source: library:/prog8lib/cx16/textio.p8:14   const ubyte DEFAULT_HEIGHT = 60
	; source: library:/prog8lib/cx16/textio.p8:15   const long VERA_TEXTMATRIX = $1b000
	; source: library:/prog8lib/cx16/textio.p8:11   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/cx16/textio.p8:17   extsub $FFD2 = chrout(ubyte character @ A)    ; for consistency. You can also use cbm.CHROUT directly ofcourse. Note: takes a PETSCII encoded character.

	; source: library:/prog8lib/cx16/textio.p8:24   asmsub column(ubyte col @A) clobbers(A, X, Y) {

column	.proc
	; source: library:/prog8lib/cx16/textio.p8:26   %asm {{
        pha
        sec
        jsr  cbm.PLOT
        pla
        tay
        clc
        jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:37   asmsub get_column() -> ubyte @Y {

get_column	.proc
	; source: library:/prog8lib/cx16/textio.p8:38   %asm {{
        sec
        jmp cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:44   asmsub row(ubyte rownum @A) clobbers(A, X, Y) {

row	.proc
	; source: library:/prog8lib/cx16/textio.p8:46   %asm {{
        pha
        sec
        jsr  cbm.PLOT
        pla
        tax
        clc
        jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:57   asmsub get_row() -> ubyte @X {

get_row	.proc
	; source: library:/prog8lib/cx16/textio.p8:58   %asm {{
        sec
        jmp cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:64   asmsub get_cursor() -> ubyte @X, ubyte @Y {

get_cursor	.proc
	; source: library:/prog8lib/cx16/textio.p8:65   %asm {{
        sec
        jsr  cbm.PLOT
        phx     ; swap X and Y
        phy
        plx
        ply
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:76   asmsub  fill_screen (ubyte character @ A, ubyte color @ Y) clobbers(A, X)  {

fill_screen	.proc
	; source: library:/prog8lib/cx16/textio.p8:78   %asm {{
_color = P8ZP_SCRATCH_B1
_numrows = P8ZP_SCRATCH_REG
        sty  _color
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _numrows
        lda  #%00010000
        jsr  set_vera_textmatrix_addresses
        pla
_more   ldx  _numrows
        phy
        ldy  _color
-       sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        dex
        bne  -
        ply
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _more
+       rts

set_vera_textmatrix_addresses:
        stz  cx16.VERA_CTRL
        ora  #VERA_TEXTMATRIX>>16
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L       ; start at (0,0)
        lda  #>VERA_TEXTMATRIX
        sta  cx16.VERA_ADDR_M
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:124   asmsub  clear_screenchars (ubyte character @ A) clobbers(X, Y)  {

clear_screenchars	.proc
	; source: library:/prog8lib/cx16/textio.p8:127   %asm {{
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  P8ZP_SCRATCH_REG
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        pla
_more   ldx  P8ZP_SCRATCH_REG
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _more
+       rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:153   asmsub  clear_screencolors (ubyte color @ A) clobbers(X, Y)  {

clear_screencolors	.proc
	; source: library:/prog8lib/cx16/textio.p8:156   %asm {{
_color = P8ZP_SCRATCH_B1
_numrows = P8ZP_SCRATCH_REG
        sta  _color
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _numrows
        stz  cx16.VERA_CTRL
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        inc  cx16.VERA_ADDR_L       ; start at (1,0) - the color attribute byte
_more   ldx  _numrows
        lda  _color
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        lda  #1
        sta  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _more
+       rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:253   asmsub  scroll_left() clobbers(A, X, Y)  {

scroll_left	.proc
	; source: library:/prog8lib/cx16/textio.p8:256   %asm {{
	    jsr  cbm.SCREEN
	    dex
	    stx  P8ZP_SCRATCH_REG   ; columns
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00010000 | VERA_TEXTMATRIX>>16        ; auto increment 1
        sta  cx16.VERA_ADDR_H
        lda  #2
        sta  cx16.VERA_ADDR_L   ; begin in column 1
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00010000  | VERA_TEXTMATRIX>>16         ; auto increment 1
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

        ldx  P8ZP_SCRATCH_REG   ; columns
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:297   asmsub  scroll_right() clobbers(A,X,Y)  {

scroll_right	.proc
	; source: library:/prog8lib/cx16/textio.p8:300   %asm {{
_columns = P8ZP_SCRATCH_REG
_rcolv1 = P8ZP_SCRATCH_W1
_rcolv2 = P8ZP_SCRATCH_W1+1
	    jsr  cbm.SCREEN
	    dex
	    stx  _columns
	    txa
	    asl  a
	    dea
	    sta  _rcolv1
	    ina
	    ina
	    sta  _rcolv2
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00011000 | VERA_TEXTMATRIX>>16        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
        lda  _rcolv1
        sta  cx16.VERA_ADDR_L   ; begin in rightmost column minus one
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00011000 | VERA_TEXTMATRIX>>16        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
        lda  _rcolv2
        sta  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

        ldx  _columns
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:352   asmsub  scroll_up() clobbers(A, X, Y)  {

scroll_up	.proc
	; source: library:/prog8lib/cx16/textio.p8:355   %asm {{
	    jsr  cbm.SCREEN
	    stx  P8ZP_SCRATCH_REG       ; columns
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        lda  #1 | (>VERA_TEXTMATRIX)
        sta  cx16.VERA_ADDR_M       ; start at second line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX>>16
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        lda  #>VERA_TEXTMATRIX
        sta  cx16.VERA_ADDR_M       ; start at top line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX>>16
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  P8ZP_SCRATCH_REG       ; columns
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:400   asmsub  scroll_down() clobbers(A, X, Y)  {

scroll_down	.proc
	; source: library:/prog8lib/cx16/textio.p8:403   %asm {{
	    jsr  cbm.SCREEN
	    stx  P8ZP_SCRATCH_REG       ; columns
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        dey
        tya
        clc
        adc  #>VERA_TEXTMATRIX
        sta  cx16.VERA_ADDR_M       ; start at line before bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX>>16
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        iny
        tya
        clc
        adc  #>VERA_TEXTMATRIX
        sta  cx16.VERA_ADDR_M       ; start at bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX>>16
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  P8ZP_SCRATCH_REG       ; columns
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:454   asmsub  setchr  (ubyte col @X, ubyte row @Y, ubyte character @A) clobbers(A)  {

setchr	.proc
	; source: library:/prog8lib/cx16/textio.p8:456   %asm {{
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX>>16
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:474   asmsub  getchr  (ubyte col @A, ubyte row @Y) -> ubyte @ A {

getchr	.proc
	; source: library:/prog8lib/cx16/textio.p8:476   %asm  {{
            asl  a
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX>>16
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:493   asmsub  setclr  (ubyte col @X, ubyte row @Y, ubyte color @A) clobbers(A)  {

setclr	.proc
	; source: library:/prog8lib/cx16/textio.p8:497   %asm {{
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX>>16
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            ina
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:516   asmsub  getclr  (ubyte col @A, ubyte row @Y) -> ubyte @ A {

getclr	.proc
	; source: library:/prog8lib/cx16/textio.p8:518   %asm  {{
            asl  a
            ina
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX>>16
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:593   asmsub  plot  (ubyte col @ Y, ubyte row @ X) {

plot	.proc
	; source: library:/prog8lib/cx16/textio.p8:594   %asm  {{
		clc
		jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:600   asmsub width() clobbers(X,Y) -> ubyte @A {

width	.proc
	; source: library:/prog8lib/cx16/textio.p8:602   %asm {{
        jsr  cbm.SCREEN
        txa
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:609   asmsub height() clobbers(X, Y) -> ubyte @A {

height	.proc
	; source: library:/prog8lib/cx16/textio.p8:611   %asm {{
        jsr  cbm.SCREEN
        tya
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:618   asmsub size() clobbers(A) -> ubyte @X, ubyte @Y {

size	.proc
	; source: library:/prog8lib/cx16/textio.p8:620   %asm {{
        jmp  cbm.SCREEN
	.pend
	; source: library:/prog8lib/cx16/textio.p8:625   asmsub waitkey() -> ubyte @A {

waitkey	.proc
	; source: library:/prog8lib/cx16/textio.p8:626   %asm {{
-       jsr cbm.GETIN
        beq -
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:633   asmsub chrout_lit(ubyte character @A) {

chrout_lit	.proc
	; source: library:/prog8lib/cx16/textio.p8:635   %asm {{
        tax
        lda  #128
        jsr  cbm.CHROUT
        txa
        jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:644   asmsub print_lit(str text @ AY) clobbers(A,Y)  {

print_lit	.proc
	; source: library:/prog8lib/cx16/textio.p8:646   %asm {{
        sta  P8ZP_SCRATCH_W2
        sty  P8ZP_SCRATCH_W2+1
        ldy  #0
-       lda  (P8ZP_SCRATCH_W2),y
        beq  +
        tax
        lda  #128
        jsr  cbm.CHROUT
        txa
        jsr  cbm.CHROUT
        iny
        bne  -
+       rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:35   asmsub  print (str text @ AY) clobbers(A,Y)  {

print	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:40   %asm {{
    		sta  P8ZP_SCRATCH_W2
    		sty  P8ZP_SCRATCH_W2+1
    		ldy  #0
-	    	lda  (P8ZP_SCRATCH_W2),y
    		beq  +
    		jsr  cbm.CHROUT
    		iny
    		bne  -
+	    	rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:53   asmsub  print_ubhex  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubhex	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:55   %asm {{
            bcc  +
            pha
            lda  #'$'
            jsr  cbm.CHROUT
            pla
+           jsr  conv.internal_ubyte2hex
            jsr  cbm.CHROUT
            tya
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:68   asmsub  print_ubbin  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubbin	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:70   %asm {{
            sta  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'%'
            jsr  cbm.CHROUT
+           ldy  #8
-           lda  #'0'
            asl  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
+           jsr  cbm.CHROUT
            dey
            bne  -
            rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:87   asmsub  print_uwbin  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwbin	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:89   %asm {{
            pha
            tya
            jsr  print_ubbin
            pla
            clc
            jmp  print_ubbin
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:99   asmsub  print_uwhex  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwhex	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:102   %asm {{
            pha
            tya
            jsr  print_ubhex
            pla
            clc
            jmp  print_ubhex
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:118   asmsub  print_uw0  (uword value @ AY) clobbers(A,X,Y)  {

print_uw0	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:120   %asm {{
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  +
            jsr  cbm.CHROUT
            iny
            bne  -
+           rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:132   asmsub  print_uw  (uword value @ AY) clobbers(A,X,Y)  {

print_uw	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:134   %asm {{
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   jsr  cbm.CHROUT
            iny
            lda  conv.internal_uword2decimal.decTenThousands,y
            bne  _gotdigit
            rts
_allzero    lda  #'0'
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:153   asmsub  print_w  (word value @ AY) clobbers(A,X,Y)  {

print_w	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:155   %asm {{
            cpy  #0
            bpl  +
            pha
            lda  #'-'
            jsr  cbm.CHROUT
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+           jmp  print_uw
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:179   asmsub  input_chars  (^^ubyte buffer @ AY) clobbers(A) -> ubyte @ Y  {

input_chars	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:184   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0				; char counter = 0
-           jsr  cbm.CHRIN
            cmp  #$0d			; return (ascii 13) pressed?
            beq  +				; yes, end.
            sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
            iny
            bne  -
+           lda  #0
            sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
            rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:200   asmsub petscii2scr(ubyte petscii_char @A) -> ubyte @A {

petscii2scr	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:202   %asm {{
            sta  P8ZP_SCRATCH_REG
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            tax
            lda  _offsets,x
            eor  P8ZP_SCRATCH_REG
            rts
_offsets    .byte  128, 0, 64, 32, 64, 192, 128, 128
            ; !notreached!
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:218   asmsub petscii2scr_str(str petscii_string @AY) {

petscii2scr_str	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:220   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  +
            jsr  petscii2scr
            sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
+           rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:242   asmsub  print_ub0  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub0	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:244   %asm {{
            jsr  conv.internal_ubyte2decimal
            pha
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            pla
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:256   asmsub  print_ub  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:258   %asm {{
            jsr  conv.internal_ubyte2decimal
_print_byte_digits
            pha
            cpy  #'0'
            beq  +
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            jmp  _ones
+           cpx  #'0'
            beq  _ones
            txa
            jsr  cbm.CHROUT
_ones       pla
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:278   asmsub  print_b  (byte value @ A) clobbers(A,X,Y)  {

print_b	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:280   %asm {{
            pha
            cmp  #0
            bpl  +
            lda  #'-'
            jsr  cbm.CHROUT
+		    pla
            jsr  conv.internal_byte2decimal
            jmp  print_ub._print_byte_digits
	.pend
	.pend

; ---- block: 'cbm' ----
cbm	.proc
	; source: library:/prog8lib/cx16/syslib.p8:6   cbm {
	IERROR = $0300
	IMAIN = $0302
	ICRNCH = $0304
	IQPLOP = $0306
	IGONE = $0308
	IEVAL = $030a
	SAREG = $030c
	SXREG = $030d
	SYREG = $030e
	SPREG = $030f
	USRADD = $0311
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	IOPEN = $031a
	ICLOSE = $031c
	ICHKIN = $031e
	ICKOUT = $0320
	ICLRCH = $0322
	IBASIN = $0324
	IBSOUT = $0326
	ISTOP = $0328
	IGETIN = $032a
	ICLALL = $032c
	ILOAD = $0330
	ISAVE = $0332
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe

	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3

	; source: library:/prog8lib/cx16/syslib.p8:10   &uword  IERROR      = $0300
	; source: library:/prog8lib/cx16/syslib.p8:11   &uword  IMAIN       = $0302
	; source: library:/prog8lib/cx16/syslib.p8:12   &uword  ICRNCH      = $0304
	; source: library:/prog8lib/cx16/syslib.p8:13   &uword  IQPLOP      = $0306
	; source: library:/prog8lib/cx16/syslib.p8:14   &uword  IGONE       = $0308
	; source: library:/prog8lib/cx16/syslib.p8:15   &uword  IEVAL       = $030a
	; source: library:/prog8lib/cx16/syslib.p8:16   &ubyte  SAREG       = $030c     ; register storage for A for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:17   &ubyte  SXREG       = $030d     ; register storage for X for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:18   &ubyte  SYREG       = $030e     ; register storage for Y for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:19   &ubyte  SPREG       = $030f     ; register storage for P (status register) for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:20   &uword  USRADD      = $0311     ; vector for the USR() basic command
	; source: library:/prog8lib/cx16/syslib.p8:22   &uword  CINV        = $0314     ; IRQ vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:23   &uword  CBINV       = $0316     ; BRK vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:24   &uword  NMINV       = $0318     ; NMI vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:25   &uword  IOPEN       = $031a
	; source: library:/prog8lib/cx16/syslib.p8:26   &uword  ICLOSE      = $031c
	; source: library:/prog8lib/cx16/syslib.p8:27   &uword  ICHKIN      = $031e
	; source: library:/prog8lib/cx16/syslib.p8:28   &uword  ICKOUT      = $0320
	; source: library:/prog8lib/cx16/syslib.p8:29   &uword  ICLRCH      = $0322
	; source: library:/prog8lib/cx16/syslib.p8:30   &uword  IBASIN      = $0324
	; source: library:/prog8lib/cx16/syslib.p8:31   &uword  IBSOUT      = $0326
	; source: library:/prog8lib/cx16/syslib.p8:32   &uword  ISTOP       = $0328
	; source: library:/prog8lib/cx16/syslib.p8:33   &uword  IGETIN      = $032a
	; source: library:/prog8lib/cx16/syslib.p8:34   &uword  ICLALL      = $032c
	; source: library:/prog8lib/cx16/syslib.p8:36   &uword  ILOAD       = $0330
	; source: library:/prog8lib/cx16/syslib.p8:37   &uword  ISAVE       = $0332
	; source: library:/prog8lib/cx16/syslib.p8:38   &uword  NMI_VEC     = $FFFA     ; 65c02 nmi vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:39   &uword  RESET_VEC   = $FFFC     ; 65c02 reset vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:40   &uword  IRQ_VEC     = $FFFE     ; 65c02 interrupt vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:6   cbm {
	; source: library:/prog8lib/cx16/syslib.p8:47   extsub $FF81 = CINT() clobbers(A,X,Y)                           ; (alias: SCINIT) initialize screen editor and video chip, including resetting to the default color palette. Note: also sets the video mode back to VGA

	; source: library:/prog8lib/cx16/syslib.p8:48   extsub $FF84 = IOINIT() clobbers(A, X)                          ; initialize I/O devices (CIA, IRQ, ...)

	; source: library:/prog8lib/cx16/syslib.p8:49   extsub $FF87 = RAMTAS() clobbers(A,X,Y)                         ; initialize RAM, screen

	; source: library:/prog8lib/cx16/syslib.p8:50   extsub $FF8A = RESTOR() clobbers(A,X,Y)                         ; restore default I/O vectors

	; source: library:/prog8lib/cx16/syslib.p8:51   extsub $FF8D = VECTOR(uword userptr @ XY, bool dir @ Pc) clobbers(A,Y)     ; read/set I/O vector table

	; source: library:/prog8lib/cx16/syslib.p8:52   extsub $FF90 = SETMSG(ubyte value @ A)                          ; set Kernal message control flag

	; source: library:/prog8lib/cx16/syslib.p8:53   extsub $FF93 = SECOND(ubyte address @ A) clobbers(A)            ; (alias: LSTNSA) send secondary address after LISTEN

	; source: library:/prog8lib/cx16/syslib.p8:54   extsub $FF96 = TKSA(ubyte address @ A) clobbers(A)              ; (alias: TALKSA) send secondary address after TALK

	; source: library:/prog8lib/cx16/syslib.p8:55   extsub $FF99 = MEMTOP(uword address @ XY, bool dir @ Pc) -> uword @ XY, ubyte @A     ; read/set top of memory  pointer.   NOTE: on the Cx16 also returns the number of RAM memory banks in A!  Also see cx16.numbanks()

	; source: library:/prog8lib/cx16/syslib.p8:56   extsub $FF9C = MEMBOT(uword address @ XY, bool dir @ Pc) -> uword @ XY     ; read/set bottom of memory  pointer

	; source: library:/prog8lib/cx16/syslib.p8:57   extsub $FF9F = SCNKEY() clobbers(A,X,Y)                         ; scan the keyboard, also called  kbd_scan

	; source: library:/prog8lib/cx16/syslib.p8:58   extsub $FFA2 = SETTMO(ubyte timeout @ A)                        ; set time-out flag for IEEE bus

	; source: library:/prog8lib/cx16/syslib.p8:59   extsub $FFA5 = ACPTR() -> ubyte @ A                             ; (alias: IECIN) input byte from serial bus

	; source: library:/prog8lib/cx16/syslib.p8:60   extsub $FFA8 = CIOUT(ubyte databyte @ A)                        ; (alias: IECOUT) output byte to serial bus

	; source: library:/prog8lib/cx16/syslib.p8:61   extsub $FFAB = UNTLK() clobbers(A)                              ; command serial bus device to UNTALK

	; source: library:/prog8lib/cx16/syslib.p8:62   extsub $FFAE = UNLSN() clobbers(A)                              ; command serial bus device to UNLISTEN

	; source: library:/prog8lib/cx16/syslib.p8:63   extsub $FFB1 = LISTEN(ubyte device @ A) clobbers(A)             ; command serial bus device to LISTEN

	; source: library:/prog8lib/cx16/syslib.p8:64   extsub $FFB4 = TALK(ubyte device @ A) clobbers(A)               ; command serial bus device to TALK

	; source: library:/prog8lib/cx16/syslib.p8:65   extsub $FFB7 = READST() -> ubyte @ A                            ; read I/O status word  (use CLEARST to reset it to 0)

	; source: library:/prog8lib/cx16/syslib.p8:66   extsub $FFBA = SETLFS(ubyte logical @ A, ubyte device @ X, ubyte secondary @ Y)   ; set logical file parameters

	; source: library:/prog8lib/cx16/syslib.p8:67   extsub $FFBD = SETNAM(ubyte namelen @ A, str filename @ XY)     ; set filename parameters

	; source: library:/prog8lib/cx16/syslib.p8:68   extsub $FFC0 = OPEN() clobbers(X,Y) -> bool @Pc, ubyte @A       ; (via 794 ($31A)) open a logical file

	; source: library:/prog8lib/cx16/syslib.p8:69   extsub $FFC3 = CLOSE(ubyte logical @ A) clobbers(A,X,Y)         ; (via 796 ($31C)) close a logical file

	; source: library:/prog8lib/cx16/syslib.p8:70   extsub $FFC6 = CHKIN(ubyte logical @ X) clobbers(A,X) -> bool @Pc    ; (via 798 ($31E)) define an input channel

	; source: library:/prog8lib/cx16/syslib.p8:71   extsub $FFC9 = CHKOUT(ubyte logical @ X) clobbers(A,X)          ; (via 800 ($320)) define an output channel

	; source: library:/prog8lib/cx16/syslib.p8:72   extsub $FFCC = CLRCHN() clobbers(A,X)                           ; (via 802 ($322)) restore default devices

	; source: library:/prog8lib/cx16/syslib.p8:73   extsub $FFCF = CHRIN() clobbers(X, Y) -> ubyte @ A   ; (via 804 ($324)) input a character (for keyboard, read a whole line from the screen) A=byte read.

	; source: library:/prog8lib/cx16/syslib.p8:74   extsub $FFD2 = CHROUT(ubyte character @ A)                           ; (via 806 ($326)) output a character

	; source: library:/prog8lib/cx16/syslib.p8:75   extsub $FFD5 = LOAD(ubyte verify @ A, uword address @ XY) -> bool @Pc, ubyte @ A, uword @ XY     ; (via 816 ($330)) load from device

	; source: library:/prog8lib/cx16/syslib.p8:76   extsub $FFD8 = SAVE(ubyte zp_startaddr @ A, uword endaddr @ XY) clobbers (X, Y) -> bool @ Pc, ubyte @ A       ; (via 818 ($332)) save to a device.  See also BSAVE

	; source: library:/prog8lib/cx16/syslib.p8:77   extsub $FFDB = SETTIM(ubyte low @ A, ubyte middle @ X, ubyte high @ Y)      ; set the software clock

	; source: library:/prog8lib/cx16/syslib.p8:78   extsub $FFDE = RDTIM() -> ubyte @ A, ubyte @ X, ubyte @ Y       ; read the software clock (in little endian order: A=lo,X=mid,Y=high) , however use RDTIM_safe() instead

	; source: library:/prog8lib/cx16/syslib.p8:79   extsub $FFE1 = STOP() clobbers(X) -> bool @ Pz, ubyte @ A       ; (via 808 ($328)) check the STOP key (and some others in A)        also see STOP2

	; source: library:/prog8lib/cx16/syslib.p8:80   extsub $FFE4 = GETIN() clobbers(X,Y) -> bool @Pc, ubyte @ A     ; (via 810 ($32A)) get a character      also see GETIN2

	; source: library:/prog8lib/cx16/syslib.p8:81   extsub $FFE7 = CLALL() clobbers(A,X)                            ; (via 812 ($32C)) close all files

	; source: library:/prog8lib/cx16/syslib.p8:82   extsub $FFEA = UDTIM() clobbers(A,X)                            ; update the software clock

	; source: library:/prog8lib/cx16/syslib.p8:83   extsub $FFED = SCREEN() -> ubyte @ X, ubyte @ Y                 ; get size of text screen into X (columns) and Y (rows)

	; source: library:/prog8lib/cx16/syslib.p8:84   extsub $FFF0 = PLOT(ubyte col @ Y, ubyte row @ X, bool dir @ Pc) clobbers(A) -> ubyte @ Y, ubyte @ X       ; read/set position of cursor on screen (Y=column, X=row).  Also see txt.plot

	; source: library:/prog8lib/cx16/syslib.p8:85   extsub $FFF3 = IOBASE() -> uword @ XY                           ; read base address of I/O devices

	; source: library:/prog8lib/cx16/syslib.p8:89   inline asmsub STOP2() clobbers(X,A) -> bool @Pz  {
	; source: library:/prog8lib/cx16/syslib.p8:97   inline asmsub GETIN2() clobbers(X,Y) -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:106   asmsub RDTIM_safe() -> ubyte @ A, ubyte @ X, ubyte @ Y {

RDTIM_safe	.proc
	; source: library:/prog8lib/cx16/syslib.p8:109   %asm {{
        php
        sei
        jsr  cbm.RDTIM
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:118   asmsub RDTIM16() clobbers(X) -> uword @AY {

RDTIM16	.proc
	; source: library:/prog8lib/cx16/syslib.p8:120   %asm {{
        jsr  RDTIM_safe
        pha
        txa
        tay
        pla
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:130   asmsub SETTIML(long jiffies @R0R1_32) {

SETTIML	.proc
	; source: library:/prog8lib/cx16/syslib.p8:132   %asm {{
        lda  cx16.r0
        ldx  cx16.r0+1
        ldy  cx16.r0+2
        jmp  SETTIM
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:140   asmsub RDTIML() clobbers(X) -> long @R0R1_32 {

RDTIML	.proc
	; source: library:/prog8lib/cx16/syslib.p8:142   %asm {{
        jsr  RDTIM_safe
        sta  cx16.r0
        stx  cx16.r0+1
        sty  cx16.r0+2
        stz  cx16.r0+3
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:161   asmsub kbdbuf_clear() {

kbdbuf_clear	.proc
	; source: library:/prog8lib/cx16/syslib.p8:163   %asm {{
-       jsr  GETIN
        cmp  #0
        bne  -
        rts
	.pend
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	; source: library:/prog8lib/cx16/syslib.p8:173   cx16 {
	r0 = 2
	r0s = 2
	r0L = 2
	r0sL = 2
	r0bL = 2
	r0H = 3
	r0sH = 3
	r0bH = 3
	r1 = 4
	r1s = 4
	r1L = 4
	r1sL = 4
	r1bL = 4
	r1H = 5
	r1sH = 5
	r1bH = 5
	r2 = 6
	r2s = 6
	r2L = 6
	r2sL = 6
	r2bL = 6
	r2H = 7
	r2sH = 7
	r2bH = 7
	r3 = 8
	r3s = 8
	r3L = 8
	r3sL = 8
	r3bL = 8
	r3H = 9
	r3sH = 9
	r3bH = 9
	r4 = 10
	r4s = 10
	r4L = 10
	r4sL = 10
	r4bL = 10
	r4H = 11
	r4sH = 11
	r4bH = 11
	r5 = 12
	r5s = 12
	r5L = 12
	r5sL = 12
	r5bL = 12
	r5H = 13
	r5sH = 13
	r5bH = 13
	r6 = 14
	r6s = 14
	r6L = 14
	r6sL = 14
	r6bL = 14
	r6H = 15
	r6sH = 15
	r6bH = 15
	r7 = $10
	r7s = $10
	r7L = $10
	r7sL = $10
	r7bL = $10
	r7H = $11
	r7sH = $11
	r7bH = $11
	r8 = $12
	r8s = $12
	r8L = $12
	r8sL = $12
	r8bL = $12
	r8H = $13
	r8sH = $13
	r8bH = $13
	r9 = $14
	r9s = $14
	r9L = $14
	r9sL = $14
	r9bL = $14
	r9H = $15
	r9sH = $15
	r9bH = $15
	r10 = $16
	r10s = $16
	r10L = $16
	r10sL = $16
	r10bL = $16
	r10H = $17
	r10sH = $17
	r10bH = $17
	r11 = $18
	r11s = $18
	r11L = $18
	r11sL = $18
	r11bL = $18
	r11H = $19
	r11sH = $19
	r11bH = $19
	r12 = $1a
	r12s = $1a
	r12L = $1a
	r12sL = $1a
	r12bL = $1a
	r12H = $1b
	r12sH = $1b
	r12bH = $1b
	r13 = $1c
	r13s = $1c
	r13L = $1c
	r13sL = $1c
	r13bL = $1c
	r13H = $1d
	r13sH = $1d
	r13bH = $1d
	r14 = $1e
	r14s = $1e
	r14L = $1e
	r14sL = $1e
	r14bL = $1e
	r14H = $1f
	r14sH = $1f
	r14bH = $1f
	r15 = $20
	r15s = $20
	r15L = $20
	r15sL = $20
	r15bL = $20
	r15H = $21
	r15sH = $21
	r15bH = $21
	KEYHDL = $032e
	stavec = $03b2
	via1prb = $9f00
	via1pra = $9f01
	via1ddrb = $9f02
	via1ddra = $9f03
	via1t1l = $9f04
	via1t1h = $9f05
	via1t1ll = $9f06
	via1t1lh = $9f07
	via1t2l = $9f08
	via1t2h = $9f09
	via1sr = $9f0a
	via1acr = $9f0b
	via1pcr = $9f0c
	via1ifr = $9f0d
	via1ier = $9f0e
	via1ora = $9f0f
	via2prb = $9f10
	via2pra = $9f11
	via2ddrb = $9f12
	via2ddra = $9f13
	via2t1l = $9f14
	via2t1h = $9f15
	via2t1ll = $9f16
	via2t1lh = $9f17
	via2t2l = $9f18
	via2t2h = $9f19
	via2sr = $9f1a
	via2acr = $9f1b
	via2pcr = $9f1c
	via2ifr = $9f1d
	via2ier = $9f1e
	via2ora = $9f1f
	VERA_ADDR_L = $9f20
	VERA_ADDR = $9f20
	VERA_ADDR_M = $9f21
	VERA_ADDR_H = $9f22
	VERA_DATA0 = $9f23
	VERA_DATA1 = $9f24
	VERA_CTRL = $9f25
	VERA_IEN = $9f26
	VERA_ISR = $9f27
	VERA_IRQLINE_L = $9f28
	VERA_SCANLINE_L = $9f28
	VERA_DC_VIDEO = $9f29
	VERA_DC_HSTART = $9f29
	VERA_DC_VER0 = $9f29
	VERA_FX_CTRL = $9f29
	VERA_FX_X_INCR_L = $9f29
	VERA_FX_X_INCR = $9f29
	VERA_FX_X_POS_L = $9f29
	VERA_FX_X_POS = $9f29
	VERA_FX_X_POS_S = $9f29
	VERA_FX_CACHE_L = $9f29
	VERA_FX_ACCUM_RESET = $9f29
	VERA_DC_HSCALE = $9f2a
	VERA_DC_HSTOP = $9f2a
	VERA_DC_VER1 = $9f2a
	VERA_FX_TILEBASE = $9f2a
	VERA_FX_X_INCR_H = $9f2a
	VERA_FX_X_POS_H = $9f2a
	VERA_FX_Y_POS_S = $9f2a
	VERA_FX_CACHE_M = $9f2a
	VERA_FX_ACCUM = $9f2a
	VERA_DC_VSCALE = $9f2b
	VERA_DC_VSTART = $9f2b
	VERA_DC_VER2 = $9f2b
	VERA_FX_MAPBASE = $9f2b
	VERA_FX_Y_INCR_L = $9f2b
	VERA_FX_Y_INCR = $9f2b
	VERA_FX_Y_POS_L = $9f2b
	VERA_FX_Y_POS = $9f2b
	VERA_FX_POLY_FILL_L = $9f2b
	VERA_FX_POLY_FILL = $9f2b
	VERA_FX_CACHE_H = $9f2b
	VERA_DC_BORDER = $9f2c
	VERA_DC_VSTOP = $9f2c
	VERA_DC_VER3 = $9f2c
	VERA_FX_MULT = $9f2c
	VERA_FX_Y_INCR_H = $9f2c
	VERA_FX_Y_POS_H = $9f2c
	VERA_FX_POLY_FILL_H = $9f2c
	VERA_FX_CACHE_U = $9f2c
	VERA_L0_CONFIG = $9f2d
	VERA_L0_MAPBASE = $9f2e
	VERA_L0_TILEBASE = $9f2f
	VERA_L0_HSCROLL_L = $9f30
	VERA_L0_HSCROLL = $9f30
	VERA_L0_HSCROLL_H = $9f31
	VERA_L0_VSCROLL_L = $9f32
	VERA_L0_VSCROLL = $9f32
	VERA_L0_VSCROLL_H = $9f33
	VERA_L1_CONFIG = $9f34
	VERA_L1_MAPBASE = $9f35
	VERA_L1_TILEBASE = $9f36
	VERA_L1_HSCROLL_L = $9f37
	VERA_L1_HSCROLL = $9f37
	VERA_L1_HSCROLL_H = $9f38
	VERA_L1_VSCROLL_L = $9f39
	VERA_L1_VSCROLL = $9f39
	VERA_L1_VSCROLL_H = $9f3a
	VERA_AUDIO_CTRL = $9f3b
	VERA_AUDIO_RATE = $9f3c
	VERA_AUDIO_DATA = $9f3d
	VERA_SPI_DATA = $9f3e
	VERA_SPI_CTRL = $9f3f
	YM_ADDRESS = $9f40
	YM_DATA = $9f41
	edkeyvec = $ac03
	edkeybk = $ac05
	EXTAPI16_stack_enter_kernal_stack = 3
	EXTAPI16_stack_leave_kernal_stack = 4
	EXTAPI16_stack_pop = 2
	EXTAPI16_stack_push = 1
	EXTAPI16_test = 0
	EXTAPI_clear_status = 1
	EXTAPI_cursor_blink = 10
	EXTAPI_default_palette = $10
	EXTAPI_getlfs = 2
	EXTAPI_iso_cursor_char = 5
	EXTAPI_joystick_ps2_keycodes = 4
	EXTAPI_kbd_leds = 14
	EXTAPI_led_update = 11
	EXTAPI_memory_decompress_from_func = 15
	EXTAPI_mouse_set_position = 12
	EXTAPI_mouse_sprite_offset = 3
	EXTAPI_pfkey = 7
	EXTAPI_ps2data_fetch = 8
	EXTAPI_ps2data_raw = 9
	EXTAPI_ps2kbd_typematic = 6
	EXTAPI_scnsiz = 13
	VERA_BASE = $9f20
	VIA1_BASE = $9f00
	VIA2_BASE = $9f10
	extdev = $9f60

	CLOSE_ALL = $ff4a
	LKUPLA = $ff59
	LKUPSA = $ff5c
	screen_mode = $ff5f
	screen_set_charset = $ff62
	JSRFAR = $ff6e
	fetch = $ff74
	stash = $ff77
	PRIMM = $ff7d
	GRAPH_init = $ff20
	GRAPH_clear = $ff23
	GRAPH_set_window = $ff26
	GRAPH_set_colors = $ff29
	GRAPH_draw_line = $ff2c
	GRAPH_draw_rect = $ff2f
	GRAPH_move_rect = $ff32
	GRAPH_draw_oval = $ff35
	GRAPH_draw_image = $ff38
	GRAPH_set_font = $ff3b
	GRAPH_get_char_size = $ff3e
	GRAPH_put_char = $ff41
	GRAPH_put_next_char = $ff41
	FB_init = $fef6
	FB_get_info = $fef9
	FB_set_palette = $fefc
	FB_cursor_position = $feff
	FB_cursor_next_line = $ff02
	FB_get_pixel = $ff05
	FB_get_pixels = $ff08
	FB_set_pixel = $ff0b
	FB_set_pixels = $ff0e
	FB_set_8_pixels = $ff11
	FB_set_8_pixels_opaque = $ff14
	FB_fill_pixels = $ff17
	FB_filter_pixels = $ff1a
	FB_move_pixels = $ff1d
	i2c_read_byte = $fec6
	i2c_write_byte = $fec9
	i2c_batch_read = $feb4
	i2c_batch_write = $feb7
	sprite_set_image = $fef0
	sprite_set_position = $fef3
	memory_fill = $fee4
	memory_copy = $fee7
	memory_crc = $feea
	memory_decompress = $feed
	console_init = $fedb
	console_put_char = $fede
	console_get_char = $fee1
	console_put_image = $fed8
	console_set_paging_message = $fed5
	entropy_get = $fecf
	extapi = $feab
	monitor = $fecc
	MACPTR = $ff44
	MCIOUT = $feb1
	BSAVE = $feba
	enter_basic = $ff47
	clock_set_date_time = $ff4d
	clock_get_date_time = $ff50
	kbdbuf_peek = $febd
	kbdbuf_get_modifiers = $fec0
	kbdbuf_put = $fec3
	keymap = $fed2
	mouse_config = $ff68
	mouse_get = $ff6b
	mouse_scan = $ff71
	joystick_scan = $ff53
	joystick_get = $ff56
	x16edit_default = $c000
	x16edit_loadfile = $c003
	x16edit_loadfile_options = $c006
	audio_init = $c09f ; @bank 10
	bas_fmfreq = $c000 ; @bank 10
	bas_fmnote = $c003 ; @bank 10
	bas_fmplaystring = $c006 ; @bank 10
	bas_fmvib = $c009 ; @bank 10
	bas_playstringvoice = $c00c ; @bank 10
	bas_psgfreq = $c00f ; @bank 10
	bas_psgnote = $c012 ; @bank 10
	bas_psgwav = $c015 ; @bank 10
	bas_psgplaystring = $c018 ; @bank 10
	bas_fmchordstring = $c08d ; @bank 10
	bas_psgchordstring = $c090 ; @bank 10
	notecon_bas2fm = $c01b ; @bank 10
	notecon_bas2midi = $c01e ; @bank 10
	notecon_bas2psg = $c021 ; @bank 10
	notecon_fm2bas = $c024 ; @bank 10
	notecon_fm2midi = $c027 ; @bank 10
	notecon_fm2psg = $c02a ; @bank 10
	notecon_freq2bas = $c02d ; @bank 10
	notecon_freq2fm = $c030 ; @bank 10
	notecon_freq2midi = $c033 ; @bank 10
	notecon_freq2psg = $c036 ; @bank 10
	notecon_midi2bas = $c039 ; @bank 10
	notecon_midi2fm = $c03c ; @bank 10
	notecon_midi2psg = $c03f ; @bank 10
	notecon_psg2bas = $c042 ; @bank 10
	notecon_psg2fm = $c045 ; @bank 10
	notecon_psg2midi = $c048 ; @bank 10
	psg_init = $c04b ; @bank 10
	psg_playfreq = $c04e ; @bank 10
	psg_read = $c051 ; @bank 10
	psg_setatten = $c054 ; @bank 10
	psg_setfreq = $c057 ; @bank 10
	psg_setpan = $c05a ; @bank 10
	psg_setvol = $c05d ; @bank 10
	psg_write = $c060 ; @bank 10
	psg_write_fast = $c0a2 ; @bank 10
	psg_getatten = $c093 ; @bank 10
	psg_getpan = $c096 ; @bank 10
	ym_init = $c063 ; @bank 10
	ym_loaddefpatches = $c066 ; @bank 10
	ym_loadpatch = $c069 ; @bank 10
	ym_loadpatchlfn = $c06c ; @bank 10
	ym_playdrum = $c06f ; @bank 10
	ym_playnote = $c072 ; @bank 10
	ym_setatten = $c075 ; @bank 10
	ym_setdrum = $c078 ; @bank 10
	ym_setnote = $c07b ; @bank 10
	ym_setpan = $c07e ; @bank 10
	ym_read = $c081 ; @bank 10
	ym_release = $c084 ; @bank 10
	ym_trigger = $c087 ; @bank 10
	ym_write = $c08a ; @bank 10
	ym_getatten = $c099 ; @bank 10
	ym_getpan = $c09c ; @bank 10
	ym_get_chip_type = $c0a5 ; @bank 10

	; source: library:/prog8lib/cx16/syslib.p8:176   &uword  KEYHDL      = $032e     ; keyboard scan code handler see examples/cx16/keyboardhandler.p8
	; source: library:/prog8lib/cx16/syslib.p8:178   &uword  edkeyvec    = $ac03     ; (ram bank 0): for intercepting BASIN/CHRIN key strokes. See set_chrin_keyhandler()
	; source: library:/prog8lib/cx16/syslib.p8:179   &ubyte  edkeybk     = $ac05     ; ...the RAM bank of the handler routine, if not in low ram
	; source: library:/prog8lib/cx16/syslib.p8:181   &ubyte  stavec      = $03b2     ; argument for stash()
	; source: library:/prog8lib/cx16/syslib.p8:185   &uword r0  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:186   &uword r1  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:187   &uword r2  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:188   &uword r3  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:189   &uword r4  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:190   &uword r5  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:191   &uword r6  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:192   &uword r7  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:193   &uword r8  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:194   &uword r9  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:195   &uword r10 = $0016
	; source: library:/prog8lib/cx16/syslib.p8:196   &uword r11 = $0018
	; source: library:/prog8lib/cx16/syslib.p8:197   &uword r12 = $001a
	; source: library:/prog8lib/cx16/syslib.p8:198   &uword r13 = $001c
	; source: library:/prog8lib/cx16/syslib.p8:199   &uword r14 = $001e
	; source: library:/prog8lib/cx16/syslib.p8:200   &uword r15 = $0020
	; source: library:/prog8lib/cx16/syslib.p8:203   &word r0s  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:204   &word r1s  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:205   &word r2s  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:206   &word r3s  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:207   &word r4s  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:208   &word r5s  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:209   &word r6s  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:210   &word r7s  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:211   &word r8s  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:212   &word r9s  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:213   &word r10s = $0016
	; source: library:/prog8lib/cx16/syslib.p8:214   &word r11s = $0018
	; source: library:/prog8lib/cx16/syslib.p8:215   &word r12s = $001a
	; source: library:/prog8lib/cx16/syslib.p8:216   &word r13s = $001c
	; source: library:/prog8lib/cx16/syslib.p8:217   &word r14s = $001e
	; source: library:/prog8lib/cx16/syslib.p8:218   &word r15s = $0020
	; source: library:/prog8lib/cx16/syslib.p8:221   &ubyte r0L  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:222   &ubyte r1L  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:223   &ubyte r2L  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:224   &ubyte r3L  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:225   &ubyte r4L  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:226   &ubyte r5L  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:227   &ubyte r6L  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:228   &ubyte r7L  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:229   &ubyte r8L  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:230   &ubyte r9L  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:231   &ubyte r10L = $0016
	; source: library:/prog8lib/cx16/syslib.p8:232   &ubyte r11L = $0018
	; source: library:/prog8lib/cx16/syslib.p8:233   &ubyte r12L = $001a
	; source: library:/prog8lib/cx16/syslib.p8:234   &ubyte r13L = $001c
	; source: library:/prog8lib/cx16/syslib.p8:235   &ubyte r14L = $001e
	; source: library:/prog8lib/cx16/syslib.p8:236   &ubyte r15L = $0020
	; source: library:/prog8lib/cx16/syslib.p8:238   &ubyte r0H  = $0003
	; source: library:/prog8lib/cx16/syslib.p8:239   &ubyte r1H  = $0005
	; source: library:/prog8lib/cx16/syslib.p8:240   &ubyte r2H  = $0007
	; source: library:/prog8lib/cx16/syslib.p8:241   &ubyte r3H  = $0009
	; source: library:/prog8lib/cx16/syslib.p8:242   &ubyte r4H  = $000b
	; source: library:/prog8lib/cx16/syslib.p8:243   &ubyte r5H  = $000d
	; source: library:/prog8lib/cx16/syslib.p8:244   &ubyte r6H  = $000f
	; source: library:/prog8lib/cx16/syslib.p8:245   &ubyte r7H  = $0011
	; source: library:/prog8lib/cx16/syslib.p8:246   &ubyte r8H  = $0013
	; source: library:/prog8lib/cx16/syslib.p8:247   &ubyte r9H  = $0015
	; source: library:/prog8lib/cx16/syslib.p8:248   &ubyte r10H = $0017
	; source: library:/prog8lib/cx16/syslib.p8:249   &ubyte r11H = $0019
	; source: library:/prog8lib/cx16/syslib.p8:250   &ubyte r12H = $001b
	; source: library:/prog8lib/cx16/syslib.p8:251   &ubyte r13H = $001d
	; source: library:/prog8lib/cx16/syslib.p8:252   &ubyte r14H = $001f
	; source: library:/prog8lib/cx16/syslib.p8:253   &ubyte r15H = $0021
	; source: library:/prog8lib/cx16/syslib.p8:256   &byte r0sL  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:257   &byte r1sL  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:258   &byte r2sL  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:259   &byte r3sL  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:260   &byte r4sL  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:261   &byte r5sL  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:262   &byte r6sL  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:263   &byte r7sL  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:264   &byte r8sL  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:265   &byte r9sL  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:266   &byte r10sL = $0016
	; source: library:/prog8lib/cx16/syslib.p8:267   &byte r11sL = $0018
	; source: library:/prog8lib/cx16/syslib.p8:268   &byte r12sL = $001a
	; source: library:/prog8lib/cx16/syslib.p8:269   &byte r13sL = $001c
	; source: library:/prog8lib/cx16/syslib.p8:270   &byte r14sL = $001e
	; source: library:/prog8lib/cx16/syslib.p8:271   &byte r15sL = $0020
	; source: library:/prog8lib/cx16/syslib.p8:273   &byte r0sH  = $0003
	; source: library:/prog8lib/cx16/syslib.p8:274   &byte r1sH  = $0005
	; source: library:/prog8lib/cx16/syslib.p8:275   &byte r2sH  = $0007
	; source: library:/prog8lib/cx16/syslib.p8:276   &byte r3sH  = $0009
	; source: library:/prog8lib/cx16/syslib.p8:277   &byte r4sH  = $000b
	; source: library:/prog8lib/cx16/syslib.p8:278   &byte r5sH  = $000d
	; source: library:/prog8lib/cx16/syslib.p8:279   &byte r6sH  = $000f
	; source: library:/prog8lib/cx16/syslib.p8:280   &byte r7sH  = $0011
	; source: library:/prog8lib/cx16/syslib.p8:281   &byte r8sH  = $0013
	; source: library:/prog8lib/cx16/syslib.p8:282   &byte r9sH  = $0015
	; source: library:/prog8lib/cx16/syslib.p8:283   &byte r10sH = $0017
	; source: library:/prog8lib/cx16/syslib.p8:284   &byte r11sH = $0019
	; source: library:/prog8lib/cx16/syslib.p8:285   &byte r12sH = $001b
	; source: library:/prog8lib/cx16/syslib.p8:286   &byte r13sH = $001d
	; source: library:/prog8lib/cx16/syslib.p8:287   &byte r14sH = $001f
	; source: library:/prog8lib/cx16/syslib.p8:288   &byte r15sH = $0021
	; source: library:/prog8lib/cx16/syslib.p8:291   &bool r0bL  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:292   &bool r1bL  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:293   &bool r2bL  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:294   &bool r3bL  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:295   &bool r4bL  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:296   &bool r5bL  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:297   &bool r6bL  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:298   &bool r7bL  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:299   &bool r8bL  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:300   &bool r9bL  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:301   &bool r10bL = $0016
	; source: library:/prog8lib/cx16/syslib.p8:302   &bool r11bL = $0018
	; source: library:/prog8lib/cx16/syslib.p8:303   &bool r12bL = $001a
	; source: library:/prog8lib/cx16/syslib.p8:304   &bool r13bL = $001c
	; source: library:/prog8lib/cx16/syslib.p8:305   &bool r14bL = $001e
	; source: library:/prog8lib/cx16/syslib.p8:306   &bool r15bL = $0020
	; source: library:/prog8lib/cx16/syslib.p8:308   &bool r0bH  = $0003
	; source: library:/prog8lib/cx16/syslib.p8:309   &bool r1bH  = $0005
	; source: library:/prog8lib/cx16/syslib.p8:310   &bool r2bH  = $0007
	; source: library:/prog8lib/cx16/syslib.p8:311   &bool r3bH  = $0009
	; source: library:/prog8lib/cx16/syslib.p8:312   &bool r4bH  = $000b
	; source: library:/prog8lib/cx16/syslib.p8:313   &bool r5bH  = $000d
	; source: library:/prog8lib/cx16/syslib.p8:314   &bool r6bH  = $000f
	; source: library:/prog8lib/cx16/syslib.p8:315   &bool r7bH  = $0011
	; source: library:/prog8lib/cx16/syslib.p8:316   &bool r8bH  = $0013
	; source: library:/prog8lib/cx16/syslib.p8:317   &bool r9bH  = $0015
	; source: library:/prog8lib/cx16/syslib.p8:318   &bool r10bH = $0017
	; source: library:/prog8lib/cx16/syslib.p8:319   &bool r11bH = $0019
	; source: library:/prog8lib/cx16/syslib.p8:320   &bool r12bH = $001b
	; source: library:/prog8lib/cx16/syslib.p8:321   &bool r13bH = $001d
	; source: library:/prog8lib/cx16/syslib.p8:322   &bool r14bH = $001f
	; source: library:/prog8lib/cx16/syslib.p8:323   &bool r15bH = $0021
	; source: library:/prog8lib/cx16/syslib.p8:328   const uword VERA_BASE       = $9F20
	; source: library:/prog8lib/cx16/syslib.p8:329   &ubyte  VERA_ADDR_L         = VERA_BASE + $0000
	; source: library:/prog8lib/cx16/syslib.p8:330   &ubyte  VERA_ADDR_M         = VERA_BASE + $0001
	; source: library:/prog8lib/cx16/syslib.p8:331   &uword  VERA_ADDR           = VERA_BASE + $0000 ; still need to do the _H separately
	; source: library:/prog8lib/cx16/syslib.p8:332   &ubyte  VERA_ADDR_H         = VERA_BASE + $0002
	; source: library:/prog8lib/cx16/syslib.p8:333   &ubyte  VERA_DATA0          = VERA_BASE + $0003
	; source: library:/prog8lib/cx16/syslib.p8:334   &ubyte  VERA_DATA1          = VERA_BASE + $0004
	; source: library:/prog8lib/cx16/syslib.p8:335   &ubyte  VERA_CTRL           = VERA_BASE + $0005
	; source: library:/prog8lib/cx16/syslib.p8:336   &ubyte  VERA_IEN            = VERA_BASE + $0006
	; source: library:/prog8lib/cx16/syslib.p8:337   &ubyte  VERA_ISR            = VERA_BASE + $0007
	; source: library:/prog8lib/cx16/syslib.p8:338   &ubyte  VERA_IRQLINE_L      = VERA_BASE + $0008 ; write only
	; source: library:/prog8lib/cx16/syslib.p8:339   &ubyte  VERA_SCANLINE_L     = VERA_BASE + $0008 ; read only
	; source: library:/prog8lib/cx16/syslib.p8:340   &ubyte  VERA_DC_VIDEO       = VERA_BASE + $0009 ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:341   &ubyte  VERA_DC_HSCALE      = VERA_BASE + $000A ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:342   &ubyte  VERA_DC_VSCALE      = VERA_BASE + $000B ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:343   &ubyte  VERA_DC_BORDER      = VERA_BASE + $000C ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:344   &ubyte  VERA_DC_HSTART      = VERA_BASE + $0009 ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:345   &ubyte  VERA_DC_HSTOP       = VERA_BASE + $000A ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:346   &ubyte  VERA_DC_VSTART      = VERA_BASE + $000B ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:347   &ubyte  VERA_DC_VSTOP       = VERA_BASE + $000C ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:348   &ubyte  VERA_DC_VER0        = VERA_BASE + $0009 ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:349   &ubyte  VERA_DC_VER1        = VERA_BASE + $000A ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:350   &ubyte  VERA_DC_VER2        = VERA_BASE + $000B ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:351   &ubyte  VERA_DC_VER3        = VERA_BASE + $000C ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:352   &ubyte  VERA_L0_CONFIG      = VERA_BASE + $000D
	; source: library:/prog8lib/cx16/syslib.p8:353   &ubyte  VERA_L0_MAPBASE     = VERA_BASE + $000E
	; source: library:/prog8lib/cx16/syslib.p8:354   &ubyte  VERA_L0_TILEBASE    = VERA_BASE + $000F
	; source: library:/prog8lib/cx16/syslib.p8:355   &ubyte  VERA_L0_HSCROLL_L   = VERA_BASE + $0010
	; source: library:/prog8lib/cx16/syslib.p8:356   &ubyte  VERA_L0_HSCROLL_H   = VERA_BASE + $0011
	; source: library:/prog8lib/cx16/syslib.p8:357   &uword  VERA_L0_HSCROLL     = VERA_BASE + $0010
	; source: library:/prog8lib/cx16/syslib.p8:358   &ubyte  VERA_L0_VSCROLL_L   = VERA_BASE + $0012
	; source: library:/prog8lib/cx16/syslib.p8:359   &ubyte  VERA_L0_VSCROLL_H   = VERA_BASE + $0013
	; source: library:/prog8lib/cx16/syslib.p8:360   &uword  VERA_L0_VSCROLL     = VERA_BASE + $0012
	; source: library:/prog8lib/cx16/syslib.p8:361   &ubyte  VERA_L1_CONFIG      = VERA_BASE + $0014
	; source: library:/prog8lib/cx16/syslib.p8:362   &ubyte  VERA_L1_MAPBASE     = VERA_BASE + $0015
	; source: library:/prog8lib/cx16/syslib.p8:363   &ubyte  VERA_L1_TILEBASE    = VERA_BASE + $0016
	; source: library:/prog8lib/cx16/syslib.p8:364   &ubyte  VERA_L1_HSCROLL_L   = VERA_BASE + $0017
	; source: library:/prog8lib/cx16/syslib.p8:365   &ubyte  VERA_L1_HSCROLL_H   = VERA_BASE + $0018
	; source: library:/prog8lib/cx16/syslib.p8:366   &uword  VERA_L1_HSCROLL     = VERA_BASE + $0017
	; source: library:/prog8lib/cx16/syslib.p8:367   &ubyte  VERA_L1_VSCROLL_L   = VERA_BASE + $0019
	; source: library:/prog8lib/cx16/syslib.p8:368   &ubyte  VERA_L1_VSCROLL_H   = VERA_BASE + $001A
	; source: library:/prog8lib/cx16/syslib.p8:369   &uword  VERA_L1_VSCROLL     = VERA_BASE + $0019
	; source: library:/prog8lib/cx16/syslib.p8:370   &ubyte  VERA_AUDIO_CTRL     = VERA_BASE + $001B
	; source: library:/prog8lib/cx16/syslib.p8:371   &ubyte  VERA_AUDIO_RATE     = VERA_BASE + $001C
	; source: library:/prog8lib/cx16/syslib.p8:372   &ubyte  VERA_AUDIO_DATA     = VERA_BASE + $001D
	; source: library:/prog8lib/cx16/syslib.p8:373   &ubyte  VERA_SPI_DATA       = VERA_BASE + $001E
	; source: library:/prog8lib/cx16/syslib.p8:374   &ubyte  VERA_SPI_CTRL       = VERA_BASE + $001F
	; source: library:/prog8lib/cx16/syslib.p8:377   &ubyte  VERA_FX_CTRL        = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:378   &ubyte  VERA_FX_TILEBASE    = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:379   &ubyte  VERA_FX_MAPBASE     = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:380   &ubyte  VERA_FX_MULT        = VERA_BASE + $000c
	; source: library:/prog8lib/cx16/syslib.p8:381   &ubyte  VERA_FX_X_INCR_L    = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:382   &ubyte  VERA_FX_X_INCR_H    = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:383   &uword  VERA_FX_X_INCR      = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:384   &ubyte  VERA_FX_Y_INCR_L    = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:385   &ubyte  VERA_FX_Y_INCR_H    = VERA_BASE + $000c
	; source: library:/prog8lib/cx16/syslib.p8:386   &uword  VERA_FX_Y_INCR      = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:387   &ubyte  VERA_FX_X_POS_L     = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:388   &ubyte  VERA_FX_X_POS_H     = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:389   &uword  VERA_FX_X_POS       = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:390   &ubyte  VERA_FX_Y_POS_L     = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:391   &ubyte  VERA_FX_Y_POS_H     = VERA_BASE + $000c
	; source: library:/prog8lib/cx16/syslib.p8:392   &uword  VERA_FX_Y_POS       = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:393   &ubyte  VERA_FX_X_POS_S     = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:394   &ubyte  VERA_FX_Y_POS_S     = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:395   &ubyte  VERA_FX_POLY_FILL_L = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:396   &ubyte  VERA_FX_POLY_FILL_H = VERA_BASE + $000c
	; source: library:/prog8lib/cx16/syslib.p8:397   &uword  VERA_FX_POLY_FILL   = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:398   &ubyte  VERA_FX_CACHE_L     = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:399   &ubyte  VERA_FX_CACHE_M     = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:400   &ubyte  VERA_FX_CACHE_H     = VERA_BASE + $000b
	; source: library:/prog8lib/cx16/syslib.p8:401   &ubyte  VERA_FX_CACHE_U     = VERA_BASE + $000c
	; source: library:/prog8lib/cx16/syslib.p8:402   &ubyte  VERA_FX_ACCUM       = VERA_BASE + $000a
	; source: library:/prog8lib/cx16/syslib.p8:403   &ubyte  VERA_FX_ACCUM_RESET = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:412   const uword  VIA1_BASE   = $9f00                  ;VIA 6522 #1
	; source: library:/prog8lib/cx16/syslib.p8:413   &ubyte  via1prb    = VIA1_BASE + 0
	; source: library:/prog8lib/cx16/syslib.p8:414   &ubyte  via1pra    = VIA1_BASE + 1
	; source: library:/prog8lib/cx16/syslib.p8:415   &ubyte  via1ddrb   = VIA1_BASE + 2
	; source: library:/prog8lib/cx16/syslib.p8:416   &ubyte  via1ddra   = VIA1_BASE + 3
	; source: library:/prog8lib/cx16/syslib.p8:417   &ubyte  via1t1l    = VIA1_BASE + 4
	; source: library:/prog8lib/cx16/syslib.p8:418   &ubyte  via1t1h    = VIA1_BASE + 5
	; source: library:/prog8lib/cx16/syslib.p8:419   &ubyte  via1t1ll   = VIA1_BASE + 6
	; source: library:/prog8lib/cx16/syslib.p8:420   &ubyte  via1t1lh   = VIA1_BASE + 7
	; source: library:/prog8lib/cx16/syslib.p8:421   &ubyte  via1t2l    = VIA1_BASE + 8
	; source: library:/prog8lib/cx16/syslib.p8:422   &ubyte  via1t2h    = VIA1_BASE + 9
	; source: library:/prog8lib/cx16/syslib.p8:423   &ubyte  via1sr     = VIA1_BASE + 10
	; source: library:/prog8lib/cx16/syslib.p8:424   &ubyte  via1acr    = VIA1_BASE + 11
	; source: library:/prog8lib/cx16/syslib.p8:425   &ubyte  via1pcr    = VIA1_BASE + 12
	; source: library:/prog8lib/cx16/syslib.p8:426   &ubyte  via1ifr    = VIA1_BASE + 13
	; source: library:/prog8lib/cx16/syslib.p8:427   &ubyte  via1ier    = VIA1_BASE + 14
	; source: library:/prog8lib/cx16/syslib.p8:428   &ubyte  via1ora    = VIA1_BASE + 15
	; source: library:/prog8lib/cx16/syslib.p8:430   const uword  VIA2_BASE   = $9f10                  ;VIA 6522 #2
	; source: library:/prog8lib/cx16/syslib.p8:431   &ubyte  via2prb    = VIA2_BASE + 0
	; source: library:/prog8lib/cx16/syslib.p8:432   &ubyte  via2pra    = VIA2_BASE + 1
	; source: library:/prog8lib/cx16/syslib.p8:433   &ubyte  via2ddrb   = VIA2_BASE + 2
	; source: library:/prog8lib/cx16/syslib.p8:434   &ubyte  via2ddra   = VIA2_BASE + 3
	; source: library:/prog8lib/cx16/syslib.p8:435   &ubyte  via2t1l    = VIA2_BASE + 4
	; source: library:/prog8lib/cx16/syslib.p8:436   &ubyte  via2t1h    = VIA2_BASE + 5
	; source: library:/prog8lib/cx16/syslib.p8:437   &ubyte  via2t1ll   = VIA2_BASE + 6
	; source: library:/prog8lib/cx16/syslib.p8:438   &ubyte  via2t1lh   = VIA2_BASE + 7
	; source: library:/prog8lib/cx16/syslib.p8:439   &ubyte  via2t2l    = VIA2_BASE + 8
	; source: library:/prog8lib/cx16/syslib.p8:440   &ubyte  via2t2h    = VIA2_BASE + 9
	; source: library:/prog8lib/cx16/syslib.p8:441   &ubyte  via2sr     = VIA2_BASE + 10
	; source: library:/prog8lib/cx16/syslib.p8:442   &ubyte  via2acr    = VIA2_BASE + 11
	; source: library:/prog8lib/cx16/syslib.p8:443   &ubyte  via2pcr    = VIA2_BASE + 12
	; source: library:/prog8lib/cx16/syslib.p8:444   &ubyte  via2ifr    = VIA2_BASE + 13
	; source: library:/prog8lib/cx16/syslib.p8:445   &ubyte  via2ier    = VIA2_BASE + 14
	; source: library:/prog8lib/cx16/syslib.p8:446   &ubyte  via2ora    = VIA2_BASE + 15
	; source: library:/prog8lib/cx16/syslib.p8:449   &ubyte  YM_ADDRESS	= $9f40
	; source: library:/prog8lib/cx16/syslib.p8:450   &ubyte  YM_DATA	    = $9f41
	; source: library:/prog8lib/cx16/syslib.p8:452   const uword  extdev	= $9f60
	; source: library:/prog8lib/cx16/syslib.p8:607   const ubyte  EXTAPI_clear_status = $01
	; source: library:/prog8lib/cx16/syslib.p8:608   const ubyte  EXTAPI_getlfs = $02
	; source: library:/prog8lib/cx16/syslib.p8:609   const ubyte  EXTAPI_mouse_sprite_offset = $03
	; source: library:/prog8lib/cx16/syslib.p8:610   const ubyte  EXTAPI_joystick_ps2_keycodes = $04
	; source: library:/prog8lib/cx16/syslib.p8:611   const ubyte  EXTAPI_iso_cursor_char = $05
	; source: library:/prog8lib/cx16/syslib.p8:612   const ubyte  EXTAPI_ps2kbd_typematic = $06
	; source: library:/prog8lib/cx16/syslib.p8:613   const ubyte  EXTAPI_pfkey = $07
	; source: library:/prog8lib/cx16/syslib.p8:614   const ubyte  EXTAPI_ps2data_fetch = $08
	; source: library:/prog8lib/cx16/syslib.p8:615   const ubyte  EXTAPI_ps2data_raw = $09
	; source: library:/prog8lib/cx16/syslib.p8:616   const ubyte  EXTAPI_cursor_blink = $0A
	; source: library:/prog8lib/cx16/syslib.p8:617   const ubyte  EXTAPI_led_update = $0B
	; source: library:/prog8lib/cx16/syslib.p8:618   const ubyte  EXTAPI_mouse_set_position = $0C
	; source: library:/prog8lib/cx16/syslib.p8:619   const ubyte  EXTAPI_scnsiz = $0D
	; source: library:/prog8lib/cx16/syslib.p8:620   const ubyte  EXTAPI_kbd_leds = $0E
	; source: library:/prog8lib/cx16/syslib.p8:621   const ubyte  EXTAPI_memory_decompress_from_func = $0F
	; source: library:/prog8lib/cx16/syslib.p8:622   const ubyte  EXTAPI_default_palette = $10
	; source: library:/prog8lib/cx16/syslib.p8:625   const ubyte  EXTAPI16_test = $00
	; source: library:/prog8lib/cx16/syslib.p8:626   const ubyte  EXTAPI16_stack_push = $01
	; source: library:/prog8lib/cx16/syslib.p8:627   const ubyte  EXTAPI16_stack_pop = $02
	; source: library:/prog8lib/cx16/syslib.p8:628   const ubyte  EXTAPI16_stack_enter_kernal_stack = $03
	; source: library:/prog8lib/cx16/syslib.p8:629   const ubyte  EXTAPI16_stack_leave_kernal_stack = $04
	; source: library:/prog8lib/cx16/syslib.p8:173   cx16 {
	; source: library:/prog8lib/cx16/syslib.p8:458   extsub $ff4a = CLOSE_ALL(ubyte device @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:459   extsub $ff59 = LKUPLA(ubyte la @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:460   extsub $ff5c = LKUPSA(ubyte sa @Y)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:461   extsub $ff5f = screen_mode(ubyte mode @A, bool getCurrent @Pc) -> ubyte @A, ubyte @X, ubyte @Y, bool @Pc        ; also see SCREEN or get/set_screen_mode()

	; source: library:/prog8lib/cx16/syslib.p8:462   extsub $ff62 = screen_set_charset(ubyte charset @A, uword charsetptr @XY)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:463   extsub $ff6e = JSRFAR()  ; following word = address to call, byte after that=rom/ram bank it is in

	; source: library:/prog8lib/cx16/syslib.p8:464   extsub $ff74 = fetch(ubyte zp_startaddr @A, ubyte bank @X, ubyte index @Y)  clobbers(X) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:465   extsub $ff77 = stash(ubyte data @A, ubyte bank @X, ubyte index @Y)  clobbers(X)     ;  note: The the zero page address containing the base address is passed in stavec ($03B2)

	; source: library:/prog8lib/cx16/syslib.p8:466   extsub $ff7d = PRIMM()

	; source: library:/prog8lib/cx16/syslib.p8:469   extsub $ff20 = GRAPH_init(uword vectors @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:470   extsub $ff23 = GRAPH_clear()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:471   extsub $ff26 = GRAPH_set_window(uword x @R0, uword y @R1, uword width @R2, uword height @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:472   extsub $ff29 = GRAPH_set_colors(ubyte stroke @A, ubyte fill @X, ubyte background @Y)  clobbers (A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:473   extsub $ff2c = GRAPH_draw_line(uword x1 @R0, uword y1 @R1, uword x2 @R2, uword y2 @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:474   extsub $ff2f = GRAPH_draw_rect(uword x @R0, uword y @R1, uword width @R2, uword height @R3, uword cornerradius @R4, bool fill @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:475   extsub $ff32 = GRAPH_move_rect(uword sx @R0, uword sy @R1, uword tx @R2, uword ty @R3, uword width @R4, uword height @R5)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:476   extsub $ff35 = GRAPH_draw_oval(uword x @R0, uword y @R1, uword width @R2, uword height @R3, bool fill @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:477   extsub $ff38 = GRAPH_draw_image(uword x @R0, uword y @R1, uword ptr @R2, uword width @R3, uword height @R4)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:478   extsub $ff3b = GRAPH_set_font(uword fontptr @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:479   extsub $ff3e = GRAPH_get_char_size(ubyte baseline @A, ubyte width @X, ubyte height_or_style @Y, bool is_control @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:480   extsub $ff41 = GRAPH_put_char(uword x @R0, uword y @R1, ubyte character @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:481   extsub $ff41 = GRAPH_put_next_char(ubyte character @A)  clobbers(A,X,Y)     ; alias for the routine above that doesn't reset the position of the initial character

	; source: library:/prog8lib/cx16/syslib.p8:484   extsub $fef6 = FB_init()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:485   extsub $fef9 = FB_get_info()  clobbers(X,Y) -> byte @A, uword @R0, uword @R1    ; width=r0, height=r1

	; source: library:/prog8lib/cx16/syslib.p8:486   extsub $fefc = FB_set_palette(uword pointer @R0, ubyte index @A, ubyte colorcount @X)  clobbers(A,X,Y)      ; note: palette array must be @nosplit

	; source: library:/prog8lib/cx16/syslib.p8:487   extsub $feff = FB_cursor_position(uword x @R0, uword y @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:488   extsub $ff02 = FB_cursor_next_line(uword x @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:489   extsub $ff05 = FB_get_pixel()  clobbers(X,Y) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:490   extsub $ff08 = FB_get_pixels(uword pointer @R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:491   extsub $ff0b = FB_set_pixel(ubyte color @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:492   extsub $ff0e = FB_set_pixels(uword pointer @R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:493   extsub $ff11 = FB_set_8_pixels(ubyte pattern @A, ubyte color @X)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:494   extsub $ff14 = FB_set_8_pixels_opaque(ubyte pattern @R0, ubyte mask @A, ubyte color1 @X, ubyte color2 @Y)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:495   extsub $ff17 = FB_fill_pixels(uword count @R0, uword pstep @R1, ubyte color @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:496   extsub $ff1a = FB_filter_pixels(uword pointer @ R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:497   extsub $ff1d = FB_move_pixels(uword sx @R0, uword sy @R1, uword tx @R2, uword ty @R3, uword count @R4)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:500   extsub $fec6 = i2c_read_byte(ubyte device @X, ubyte offset @Y) clobbers (X,Y) -> ubyte @A, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:501   extsub $fec9 = i2c_write_byte(ubyte device @X, ubyte offset @Y, ubyte data @A) clobbers (A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:502   extsub $feb4 = i2c_batch_read(ubyte device @X, uword buffer @R0, uword length @R1, bool advance @Pc) clobbers(A,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:503   extsub $feb7 = i2c_batch_write(ubyte device @X, uword buffer @R0, uword length @R1, bool advance @Pc) clobbers(A,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:505   extsub $fef0 = sprite_set_image(uword pixels @R0, uword mask @R1, ubyte bpp @R2, ubyte number @A, ubyte width @X, ubyte height @Y, bool apply_mask @Pc)  clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:506   extsub $fef3 = sprite_set_position(uword x @R0, uword y @R1, ubyte number @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:507   extsub $fee4 = memory_fill(uword address @R0, uword num_bytes @R1, ubyte value @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:508   extsub $fee7 = memory_copy(uword source @R0, uword target @R1, uword num_bytes @R2)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:509   extsub $feea = memory_crc(uword address @R0, uword num_bytes @R1)  clobbers(A,X,Y) -> uword @R2

	; source: library:/prog8lib/cx16/syslib.p8:510   extsub $feed = memory_decompress(uword input @R0, uword output @R1)  clobbers(A,X,Y) -> uword @R1       ; last address +1 is result in R1

	; source: library:/prog8lib/cx16/syslib.p8:511   extsub $fedb = console_init(uword x @R0, uword y @R1, uword width @R2, uword height @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:512   extsub $fede = console_put_char(ubyte character @A, bool wrapping @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:513   extsub $fee1 = console_get_char()  clobbers(X,Y) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:514   extsub $fed8 = console_put_image(uword pointer @R0, uword width @R1, uword height @R2)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:515   extsub $fed5 = console_set_paging_message(uword msgptr @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:516   extsub $fecf = entropy_get() -> ubyte @A, ubyte @X, ubyte @Y

	; source: library:/prog8lib/cx16/syslib.p8:518   extsub $feab = extapi(ubyte callnumber @A) clobbers (A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:519   extsub $fecc = monitor()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:521   extsub $ff44 = MACPTR(ubyte length @A, uword buffer @XY, bool dontAdvance @Pc)  clobbers(A) -> bool @Pc, uword @XY

	; source: library:/prog8lib/cx16/syslib.p8:522   extsub $feb1 = MCIOUT(ubyte length @A, uword buffer @XY, bool dontAdvance @Pc)  clobbers(A) -> bool @Pc, uword @XY

	; source: library:/prog8lib/cx16/syslib.p8:523   extsub $FEBA = BSAVE(ubyte zp_startaddr @ A, uword endaddr @ XY) clobbers (X, Y) -> bool @ Pc, ubyte @ A      ; like cbm.SAVE, but omits the 2-byte prg header

	; source: library:/prog8lib/cx16/syslib.p8:524   extsub $ff47 = enter_basic(bool cold_or_warm @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:525   extsub $ff4d = clock_set_date_time(uword yearmonth @R0, uword dayhours @R1, uword minsecs @R2, uword jiffiesweekday @R3)  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:526   extsub $ff50 = clock_get_date_time()  clobbers(A, X, Y)  -> uword @R0, uword @R1, uword @R2, uword @R3   ; result registers see clock_set_date_time()

	; source: library:/prog8lib/cx16/syslib.p8:530   extsub $febd = kbdbuf_peek() -> ubyte @A, ubyte @X     ; key in A, queue length in X

	; source: library:/prog8lib/cx16/syslib.p8:531   extsub $fec0 = kbdbuf_get_modifiers() -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:532   extsub $fec3 = kbdbuf_put(ubyte key @A) clobbers(X)

	; source: library:/prog8lib/cx16/syslib.p8:533   extsub $fed2 = keymap(uword identifier @XY, bool read @Pc) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:534   extsub $ff68 = mouse_config(byte shape @A, ubyte resX @X, ubyte resY @Y)  clobbers (A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:535   extsub $ff6b = mouse_get(ubyte zdataptr @X) -> ubyte @A, byte @X    ;  use mouse_pos() instead

	; source: library:/prog8lib/cx16/syslib.p8:536   extsub $ff71 = mouse_scan()  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:537   extsub $ff53 = joystick_scan()  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:538   extsub $ff56 = joystick_get(ubyte joynr @A) -> uword @AX, bool @Y   ; note: everything is inverted even the boolean present flag.  Also see detect_joysticks() and get_all_joysticks()

	; source: library:/prog8lib/cx16/syslib.p8:541   extsub $C000 = x16edit_default() clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:542   extsub $C003 = x16edit_loadfile(ubyte firstbank @X, ubyte lastbank @Y, str filename @R0, ubyte filenameLength @R1) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:543   extsub $C006 = x16edit_loadfile_options(ubyte firstbank @X, ubyte lastbank @Y, str filename @R0,

	; source: library:/prog8lib/cx16/syslib.p8:549   extsub @bank 10  $C09F = audio_init() clobbers(A,X,Y) -> bool @Pc     ; (re)initialize both vera PSG and YM audio chips

	; source: library:/prog8lib/cx16/syslib.p8:550   extsub @bank 10  $C000 = bas_fmfreq(ubyte channel @A, uword freq @XY, bool noretrigger @Pc) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:551   extsub @bank 10  $C003 = bas_fmnote(ubyte channel @A, ubyte note @X, ubyte fracsemitone @Y, bool noretrigger @Pc) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:552   extsub @bank 10  $C006 = bas_fmplaystring(ubyte length @A, str string @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:553   extsub @bank 10  $C009 = bas_fmvib(ubyte speed @A, ubyte depth @X) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:554   extsub @bank 10  $C00C = bas_playstringvoice(ubyte channel @A) clobbers(Y)

	; source: library:/prog8lib/cx16/syslib.p8:555   extsub @bank 10  $C00F = bas_psgfreq(ubyte voice @A, uword freq @XY) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:556   extsub @bank 10  $C012 = bas_psgnote(ubyte voice @A, ubyte note @X, ubyte fracsemitone @Y) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:557   extsub @bank 10  $C015 = bas_psgwav(ubyte voice @A, ubyte waveform @X) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:558   extsub @bank 10  $C018 = bas_psgplaystring(ubyte length @A, str string @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:559   extsub @bank 10  $C08D = bas_fmchordstring(ubyte length @A, str string @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:560   extsub @bank 10  $C090 = bas_psgchordstring(ubyte length @A, str string @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:561   extsub @bank 10  $C01B = notecon_bas2fm(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:562   extsub @bank 10  $C01E = notecon_bas2midi(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:563   extsub @bank 10  $C021 = notecon_bas2psg(ubyte note @X, ubyte fracsemitone @Y) clobbers(A) -> uword @XY, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:564   extsub @bank 10  $C024 = notecon_fm2bas(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:565   extsub @bank 10  $C027 = notecon_fm2midi(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:566   extsub @bank 10  $C02A = notecon_fm2psg(ubyte note @X, ubyte fracsemitone @Y) clobbers(A) -> uword @XY, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:567   extsub @bank 10  $C02D = notecon_freq2bas(uword freqHz @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:568   extsub @bank 10  $C030 = notecon_freq2fm(uword freqHz @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:569   extsub @bank 10  $C033 = notecon_freq2midi(uword freqHz @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:570   extsub @bank 10  $C036 = notecon_freq2psg(uword freqHz @XY) clobbers(A) -> uword @XY, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:571   extsub @bank 10  $C039 = notecon_midi2bas(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:572   extsub @bank 10  $C03C = notecon_midi2fm(ubyte note @X) clobbers(A) -> ubyte @X, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:573   extsub @bank 10  $C03F = notecon_midi2psg(ubyte note @X, ubyte fracsemitone @Y) clobbers(A) -> uword @XY, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:574   extsub @bank 10  $C042 = notecon_psg2bas(uword freq @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:575   extsub @bank 10  $C045 = notecon_psg2fm(uword freq @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:576   extsub @bank 10  $C048 = notecon_psg2midi(uword freq @XY) clobbers(A) -> ubyte @X, ubyte @Y, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:577   extsub @bank 10  $C04B = psg_init() clobbers(A,X,Y)               ; (re)init Vera PSG

	; source: library:/prog8lib/cx16/syslib.p8:578   extsub @bank 10  $C04E = psg_playfreq(ubyte voice @A, uword freq @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:579   extsub @bank 10  $C051 = psg_read(ubyte offset @X, bool cookedVol @Pc) clobbers(Y) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:580   extsub @bank 10  $C054 = psg_setatten(ubyte voice @A, ubyte attenuation @X) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:581   extsub @bank 10  $C057 = psg_setfreq(ubyte voice @A, uword freq @XY) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:582   extsub @bank 10  $C05A = psg_setpan(ubyte voice @A, ubyte panning @X) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:583   extsub @bank 10  $C05D = psg_setvol(ubyte voice @A, ubyte volume @X) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:584   extsub @bank 10  $C060 = psg_write(ubyte value @A, ubyte offset @X) clobbers(Y)

	; source: library:/prog8lib/cx16/syslib.p8:585   extsub @bank 10  $C0A2 = psg_write_fast(ubyte value @A, ubyte offset @X) clobbers(Y)

	; source: library:/prog8lib/cx16/syslib.p8:586   extsub @bank 10  $C093 = psg_getatten(ubyte voice @A) clobbers(Y) -> ubyte @X

	; source: library:/prog8lib/cx16/syslib.p8:587   extsub @bank 10  $C096 = psg_getpan(ubyte voice @A) clobbers(Y) -> ubyte @X

	; source: library:/prog8lib/cx16/syslib.p8:588   extsub @bank 10  $C063 = ym_init() clobbers(A,X,Y) -> bool @Pc              ; (re)init YM chip

	; source: library:/prog8lib/cx16/syslib.p8:589   extsub @bank 10  $C066 = ym_loaddefpatches() clobbers(A,X,Y) -> bool @Pc    ; load default YM patches

	; source: library:/prog8lib/cx16/syslib.p8:590   extsub @bank 10  $C069 = ym_loadpatch(ubyte channel @A, uword patchOrAddress @XY, bool what @Pc) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:591   extsub @bank 10  $C06C = ym_loadpatchlfn(ubyte channel @A, ubyte lfn @X) clobbers(X,Y) -> ubyte @A, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:592   extsub @bank 10  $C06F = ym_playdrum(ubyte channel @A, ubyte note @X) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:593   extsub @bank 10  $C072 = ym_playnote(ubyte channel @A, ubyte kc @X, ubyte kf @Y, bool notrigger @Pc) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:594   extsub @bank 10  $C075 = ym_setatten(ubyte channel @A, ubyte attenuation @X) clobbers(Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:595   extsub @bank 10  $C078 = ym_setdrum(ubyte channel @A, ubyte note @X) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:596   extsub @bank 10  $C07B = ym_setnote(ubyte channel @A, ubyte kc @X, ubyte kf @Y) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:597   extsub @bank 10  $C07E = ym_setpan(ubyte channel @A, ubyte panning @X) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:598   extsub @bank 10  $C081 = ym_read(ubyte register @X, bool cooked @Pc) clobbers(Y) -> ubyte @A, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:599   extsub @bank 10  $C084 = ym_release(ubyte channel @A) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:600   extsub @bank 10  $C087 = ym_trigger(ubyte channel @A, bool noRelease @Pc) clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:601   extsub @bank 10  $C08A = ym_write(ubyte value @A, ubyte register @X) clobbers(Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:602   extsub @bank 10  $C099 = ym_getatten(ubyte channel @A) clobbers(Y) -> ubyte @X

	; source: library:/prog8lib/cx16/syslib.p8:603   extsub @bank 10  $C09C = ym_getpan(ubyte channel @A) clobbers(Y) -> ubyte @X

	; source: library:/prog8lib/cx16/syslib.p8:604   extsub @bank 10  $C0A5 = ym_get_chip_type() clobbers(X) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:632   asmsub set_screen_mode(ubyte mode @A) clobbers(A,X,Y) {

set_screen_mode	.proc
	; source: library:/prog8lib/cx16/syslib.p8:634   %asm {{
        clc
        jmp  screen_mode
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:640   asmsub get_screen_mode() -> ubyte @A, ubyte @X, ubyte @Y {

get_screen_mode	.proc
	; source: library:/prog8lib/cx16/syslib.p8:644   %asm {{
        sec
        jmp  screen_mode
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:650   asmsub mouse_config2(byte shape @A) clobbers (A, X, Y) {

mouse_config2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:652   %asm {{
        pha                         ; save shape
        sec
        jsr  cx16.screen_mode       ; set current screen mode and res in A, X, Y
        pla                         ; get shape back
        jmp  cx16.mouse_config
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:661   asmsub mouse_pos() -> ubyte @A, uword @R0, uword @R1, byte @X {

mouse_pos	.proc
	; source: library:/prog8lib/cx16/syslib.p8:665   %asm {{
        ldx  #cx16.r0
        jmp  cx16.mouse_get
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:681   asmsub mouse_set_pos(uword xpos @R0, uword ypos @R1) clobbers(X) {

mouse_set_pos	.proc
	; source: library:/prog8lib/cx16/syslib.p8:684   %asm {{
        ldx  #cx16.r0L
        lda  #EXTAPI_mouse_set_position
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:691   asmsub mouse_set_sprite_offset(word xoffset @R0, word yoffset @R1) clobbers(A,X,Y) {

mouse_set_sprite_offset	.proc
	; source: library:/prog8lib/cx16/syslib.p8:692   %asm {{
        clc
        lda  #EXTAPI_mouse_sprite_offset
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:699   asmsub mouse_get_sprite_offset() clobbers(A,X,Y) -> word @R0, word @R1 {

mouse_get_sprite_offset	.proc
	; source: library:/prog8lib/cx16/syslib.p8:700   %asm {{
        sec
        lda  #EXTAPI_mouse_sprite_offset
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:707   asmsub getlfs() -> ubyte @X, ubyte @A, ubyte @Y {

getlfs	.proc
	; source: library:/prog8lib/cx16/syslib.p8:709   %asm {{
        lda  #EXTAPI_mouse_set_position
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:715   asmsub iso_cursor_char(ubyte character @X) clobbers(A,X,Y) {

iso_cursor_char	.proc
	; source: library:/prog8lib/cx16/syslib.p8:717   %asm {{
        clc
        lda  #EXTAPI_iso_cursor_char
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:724   asmsub scnsiz(ubyte width @X, ubyte heigth @Y) clobbers(A,X,Y) {

scnsiz	.proc
	; source: library:/prog8lib/cx16/syslib.p8:727   %asm {{
        lda  #EXTAPI_scnsiz
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:733   asmsub memory_decompress_from_func(uword datafunction @R4, uword output @R1)  clobbers(A,X,Y) -> uword @R1  {

memory_decompress_from_func	.proc
	; source: library:/prog8lib/cx16/syslib.p8:735   %asm {{
        lda  #EXTAPI_memory_decompress_from_func
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:741   asmsub get_default_palette() -> ubyte @A, uword @XY {

get_default_palette	.proc
	; source: library:/prog8lib/cx16/syslib.p8:744   %asm {{
        sec
        lda  #EXTAPI_default_palette
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:751   asmsub set_default_palette() {

set_default_palette	.proc
	; source: library:/prog8lib/cx16/syslib.p8:754   %asm {{
        clc
        lda  #EXTAPI_default_palette
        jmp  cx16.extapi
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:761   asmsub get_charset() -> ubyte @A {

get_charset	.proc
	; source: library:/prog8lib/cx16/syslib.p8:763   %asm {{
KERNAL_MODE = $0372         ; internal kernal variable, risky to read it, but it's ben stable for many releases.
        lda  KERNAL_MODE
        beq  _end

        bit  #$40                ;ISO mode flag
        beq  +                   ;usually KERNAL_MODE 1 or 6 (| $40)
        lda  #1
        bra  _end

+       bit  #1                  ;PETSCII upper case/graphics
        bne  +                   ;usually KERNAL_MODE 2 or 4
        lda  #2
        bra  _end

+       lda  #3                   ;PETSCII upper/lower case
_end:
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:793   inline asmsub rombank(ubyte bank @A) {
	; source: library:/prog8lib/cx16/syslib.p8:800   inline asmsub rambank(ubyte bank @A) {
	; source: library:/prog8lib/cx16/syslib.p8:807   inline asmsub getrombank() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:814   inline asmsub getrambank() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:821   inline asmsub push_rombank(ubyte newbank @A) clobbers(Y) {
	; source: library:/prog8lib/cx16/syslib.p8:831   inline asmsub pop_rombank() {
	; source: library:/prog8lib/cx16/syslib.p8:839   inline asmsub push_rambank(ubyte newbank @A) clobbers(Y) {
	; source: library:/prog8lib/cx16/syslib.p8:849   inline asmsub pop_rambank() {
	; source: library:/prog8lib/cx16/syslib.p8:857   asmsub numbanks() clobbers(X) -> uword @AY {

numbanks	.proc
	; source: library:/prog8lib/cx16/syslib.p8:864   %asm {{
        sec
        jsr  cbm.MEMTOP
        ldy  #0
        cmp  #0
        bne  +
        iny
+       rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:875   asmsub vpeek(ubyte bank @A, uword address @XY) -> ubyte @A {

vpeek	.proc
	; source: library:/prog8lib/cx16/syslib.p8:878   %asm {{
                stz  cx16.VERA_CTRL
                sta  cx16.VERA_ADDR_H
                sty  cx16.VERA_ADDR_M
                stx  cx16.VERA_ADDR_L
                lda  cx16.VERA_DATA0
                rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:888   asmsub vaddr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, byte autoIncrOrDecrByOne @Y) clobbers(A) {

vaddr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:894   %asm {{
            pha
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            pla
            cpy  #0
            bmi  ++
            beq  +
            ora  #%00010000
+           sta  cx16.VERA_ADDR_H
            stz  cx16.VERA_CTRL
            rts
+           ora  #%00011000
            sta  cx16.VERA_ADDR_H
            stz  cx16.VERA_CTRL
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:918   asmsub vaddr_clone(ubyte port @A) clobbers (A,X,Y) {

vaddr_clone	.proc
	; source: library:/prog8lib/cx16/syslib.p8:922   %asm {{
        sta  VERA_CTRL
        ldx  VERA_ADDR_L
        ldy  VERA_ADDR_H
        phy
        ldy  VERA_ADDR_M
        eor  #1
        sta  VERA_CTRL
        stx  VERA_ADDR_L
        sty  VERA_ADDR_M
        ply
        sty  VERA_ADDR_H
        eor  #1
        stz  VERA_CTRL
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:940   asmsub vaddr_autoincr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, uword autoIncrAmount @R2) clobbers(A,Y) {

vaddr_autoincr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:945   %asm {{
            jsr  _setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  _determine_incr_bits
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            stz  cx16.VERA_CTRL
            rts

_setup      sta  P8ZP_SCRATCH_REG
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            rts

_determine_incr_bits
            lda  cx16.r2H
            bne  _large
            lda  cx16.r2L
            ldy  #13
-           cmp  _strides_lsb,y
            beq  +
            dey
            bpl  -
+           tya
            asl  a
            asl  a
            asl  a
            asl  a
            rts
_large      ora  cx16.r2L
            cmp  #1         ; 256
            bne  +
            lda  #9<<4
            rts
+           cmp  #2         ; 512
            bne  +
            lda  #10<<4
            rts
+           cmp  #65        ; 320
            bne  +
            lda  #14<<4
            rts
+           cmp  #130       ; 640
            bne  +
            lda  #15<<4
            rts
+           lda  #0
            rts
_strides_lsb    .byte   0,1,2,4,8,16,32,64,128,255,255,40,80,160,255,255
            ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1005   asmsub vaddr_autodecr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, uword autoDecrAmount @R2) clobbers(A,Y) {

vaddr_autodecr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1010   %asm {{
            jsr  vaddr_autoincr._setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  vaddr_autoincr._determine_incr_bits
            ora  #%00001000         ; autodecrement
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            stz  cx16.VERA_CTRL
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1024   asmsub vpoke(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers(A) {

vpoke	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1027   %asm {{
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        sty  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1039   asmsub vpoke_or(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers (A) {

vpoke_or	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1042   %asm {{
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        ora  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1056   asmsub vpoke_and(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers(A) {

vpoke_and	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1059   %asm {{
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        and  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1073   asmsub vpoke_xor(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers (A) {

vpoke_xor	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1076   %asm {{
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        eor  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1090   asmsub vpoke_mask(ubyte bank @A, uword address @R0, ubyte mask @X, ubyte value @Y) clobbers (A) {

vpoke_mask	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1093   %asm {{
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        txa
        and  cx16.VERA_DATA0
        ora  P8ZP_SCRATCH_B1
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1109   asmsub save_virtual_registers() clobbers(A,Y) {

save_virtual_registers	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1110   %asm {{
        ldy  #31
-       lda  cx16.r0,y
        sta  _cx16_vreg_storage,y
        dey
        bpl  -
        rts

        .section BSS
_cx16_vreg_storage
        .word ?,?,?,?,?,?,?,?
        .word ?,?,?,?,?,?,?,?
        .send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1127   asmsub restore_virtual_registers() clobbers(A,Y) {

restore_virtual_registers	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1128   %asm {{
        ldy  #31
-       lda  save_virtual_registers._cx16_vreg_storage,y
        sta  cx16.r0,y
        dey
        bpl  -
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1139   asmsub save_vera_context() clobbers(A) {

save_vera_context	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1141   %asm {{
        ; note cannot store this on cpu hardware stack because this gets called as a subroutine
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+1
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+2
        lda  cx16.VERA_CTRL
        sta  _vera_storage+3
        eor  #1
        sta  _vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage+4
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+5
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+6
        rts
        .section BSS
_vera_storage:  .byte ?,?,?,?,?,?,?,?
        .send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1168   asmsub restore_vera_context() clobbers(A) {

restore_vera_context	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1170   %asm {{
        lda  cx16.save_vera_context._vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+6
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+5
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+4
        sta  cx16.VERA_ADDR_L
        lda  cx16.save_vera_context._vera_storage+3
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+2
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+1
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+0
        sta  cx16.VERA_ADDR_L
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1192   asmsub set_chrin_keyhandler(ubyte handlerbank @A, uword handler @XY) clobbers(A) {

set_chrin_keyhandler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1195   %asm {{
            sei
            sta  P8ZP_SCRATCH_REG
            lda  $00
            pha
            stz  $00
            lda  P8ZP_SCRATCH_REG
            sta  cx16.edkeybk
            stx  cx16.edkeyvec
            sty  cx16.edkeyvec+1
            pla
            sta  $00
            cli
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1212   asmsub get_chrin_keyhandler() -> ubyte @R0, uword @R1 {

get_chrin_keyhandler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1214   %asm {{
            sei
            lda  $00
            pha
            stz  $00
            lda  cx16.edkeybk
            sta  cx16.r0L
            lda  cx16.edkeyvec
            ldy  cx16.edkeyvec+1
            sta  cx16.r1
            sty  cx16.r1+1
            pla
            sta  $00
            cli
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1266   inline asmsub  disable_irqs() clobbers(A) {
	; source: library:/prog8lib/cx16/syslib.p8:1274   asmsub  enable_irq_handlers(bool disable_all_irq_sources @Pc) clobbers(A,Y)  {

enable_irq_handlers	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1279   %asm {{
        php
        sei
        bcc  +
        lda  #%00001111
        trb  cx16.VERA_IEN      ; disable all IRQ sources
+       lda  #<_irq_dispatcher
        ldy  #>_irq_dispatcher
        sta  cbm.CINV
        sty  cbm.CINV+1

		lda  #<_default_1_handler
		ldy  #>_default_1_handler
		sta  _vsync_vec
		sty  _vsync_vec+1
		lda  #<_default_0_handler
		ldy  #>_default_0_handler
		sta  _line_vec
		sty  _line_vec+1
		sta  _aflow_vec
		sty  _aflow_vec+1
		sta  _sprcol_vec
		sty  _sprcol_vec+1

        plp
        rts

        .section BSS
_vsync_vec   .word  ?
_line_vec    .word  ?
_aflow_vec   .word  ?
_sprcol_vec  .word  ?
_continue_with_system_handler   .byte  ?
        .send BSS

_irq_dispatcher
        ; order of handling: LINE, SPRCOL, AFLOW, VSYNC.
        jsr  sys.save_prog8_internals
        cld
        lda  cx16.VERA_ISR
        and  cx16.VERA_IEN          ; only consider the bits for sources that can actually raise the IRQ
        sta  cx16.VERA_ISR          ; note: AFLOW can only be cleared by filling the audio FIFO for at least 1/4. Not via the ISR bit.

        stz  _continue_with_system_handler

        bit  #2         ; make sure to test for LINE IRQ first to handle that as soon as we can
        beq  +
        pha
        jsr  _line_handler
        tsb  _continue_with_system_handler
        pla

+       lsr  a
        bcc  +
        pha
        jsr  _vsync_handler
        tsb  _continue_with_system_handler
        pla

+       lsr  a
        lsr  a
        bcc  +
        pha
        jsr  _sprcol_handler
        tsb  _continue_with_system_handler
        pla

+       lsr  a
        bcc  +
        jsr  _aflow_handler
        tsb  _continue_with_system_handler

+       jsr  sys.restore_prog8_internals
        lda  _continue_with_system_handler
        beq  _no_sys_handler
		jmp  (sys.restore_irq._orig_irqvec)   ; continue with normal kernal irq routine
_no_sys_handler
		ply
		plx
		pla
		rti

_default_0_handler
        lda  #0
        rts
_default_1_handler
        lda  #1
        rts

_vsync_handler
        jmp  (_vsync_vec)
_line_handler
        jmp  (_line_vec)
_sprcol_handler
        jmp  (_sprcol_vec)
_aflow_handler
        jmp  (_aflow_vec)
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1379   asmsub set_vsync_irq_handler(uword address @AY) clobbers(A) {

set_vsync_irq_handler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1381   %asm {{
        php
        sei
        sta  enable_irq_handlers._vsync_vec
        sty  enable_irq_handlers._vsync_vec+1
        lda  #1
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1393   asmsub set_line_irq_handler(uword rasterline @R0, uword address @AY) clobbers(A,Y) {

set_line_irq_handler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1396   %asm {{
        php
        sei
        sta  enable_irq_handlers._line_vec
        sty  enable_irq_handlers._line_vec+1
        lda  cx16.r0
        ldy  cx16.r0+1
        jsr  sys.set_rasterline
        lda  #2
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1411   asmsub set_sprcol_irq_handler(uword address @AY) clobbers(A) {

set_sprcol_irq_handler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1413   %asm {{
        php
        sei
        sta  enable_irq_handlers._sprcol_vec
        sty  enable_irq_handlers._sprcol_vec+1
        lda  #4
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1425   asmsub set_aflow_irq_handler(uword address @AY) clobbers(A) {

set_aflow_irq_handler	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1428   %asm {{
        php
        sei
        sta  enable_irq_handlers._aflow_vec
        sty  enable_irq_handlers._aflow_vec+1
        lda  #8
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1441   inline asmsub  disable_irq_handlers() {
	; source: library:/prog8lib/cx16/syslib.p8:1491   asmsub get_program_args(^^ubyte buffer @R0, ubyte buf_size @R1, bool binary @Pc) {

get_program_args	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1495   %asm {{
            lda  #0
            rol  a
            sta  P8ZP_SCRATCH_REG
            lda  $00
            pha
            stz  $00
            stz  P8ZP_SCRATCH_W1
            lda  #$bf
            sta  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            sta  (cx16.r0),y
            beq  +
_continue   iny
            cpy  cx16.r1L           ; max size?
            bne  -
            beq  ++
+           lda  P8ZP_SCRATCH_REG   ; binary?
            bne  _continue
+           pla
            sta  $00
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1539   asmsub rom_version() clobbers(Y) -> ubyte @A, bool @Pc {

rom_version	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1541   %asm{{
            ; the ROM BANK is unknown on entry
            ldy  $01
            stz  $01        ; KERNEL ROM
            clc             ; prepare for released ROM
            lda  $FF80
            bpl  _final     ; pre-release versions are negative
            eor  #$FF       ; twos complement
            ina
            sec
    _final:
            sty  $01
            rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1558   sys {
	MAX_BYTE = $7f
	MAX_FLOAT = 1.7014118345E38
	MAX_UBYTE = $ff
	MAX_UWORD = $ffff
	MAX_WORD = $7fff
	MIN_BYTE = -$80
	MIN_FLOAT = -1.7014118345E38
	MIN_UBYTE = 0
	MIN_UWORD = 0
	MIN_WORD = -$8000
	SIZEOF_BOOL = 1
	SIZEOF_BYTE = 1
	SIZEOF_FLOAT = 5
	SIZEOF_LONG = 4
	SIZEOF_POINTER = 2
	SIZEOF_UBYTE = 1
	SIZEOF_UWORD = 2
	SIZEOF_WORD = 2
	target = $10


	; source: library:/prog8lib/cx16/syslib.p8:1561   const ubyte target = 16         ;  compilation target specifier.  255=virtual, 128=C128, 64=C64, 32=PET, 16=CommanderX16, 8=atari800XL, 7=Neo6502
	; source: library:/prog8lib/cx16/syslib.p8:1563   const ubyte SIZEOF_BOOL  = sizeof(bool)
	; source: library:/prog8lib/cx16/syslib.p8:1564   const ubyte SIZEOF_BYTE  = sizeof(byte)
	; source: library:/prog8lib/cx16/syslib.p8:1565   const ubyte SIZEOF_UBYTE = sizeof(ubyte)
	; source: library:/prog8lib/cx16/syslib.p8:1566   const ubyte SIZEOF_WORD  = sizeof(word)
	; source: library:/prog8lib/cx16/syslib.p8:1567   const ubyte SIZEOF_UWORD = sizeof(uword)
	; source: library:/prog8lib/cx16/syslib.p8:1568   const ubyte SIZEOF_LONG  = sizeof(long)
	; source: library:/prog8lib/cx16/syslib.p8:1569   const ubyte SIZEOF_POINTER = sizeof(&sys.wait)
	; source: library:/prog8lib/cx16/syslib.p8:1570   const ubyte SIZEOF_FLOAT = sizeof(float)
	; source: library:/prog8lib/cx16/syslib.p8:1571   const byte  MIN_BYTE     = -128
	; source: library:/prog8lib/cx16/syslib.p8:1572   const byte  MAX_BYTE     = 127
	; source: library:/prog8lib/cx16/syslib.p8:1573   const ubyte MIN_UBYTE    = 0
	; source: library:/prog8lib/cx16/syslib.p8:1574   const ubyte MAX_UBYTE    = 255
	; source: library:/prog8lib/cx16/syslib.p8:1575   const word  MIN_WORD     = -32768
	; source: library:/prog8lib/cx16/syslib.p8:1576   const word  MAX_WORD     = 32767
	; source: library:/prog8lib/cx16/syslib.p8:1577   const uword MIN_UWORD    = 0
	; source: library:/prog8lib/cx16/syslib.p8:1578   const uword MAX_UWORD    = 65535
	; source: library:/prog8lib/shared_floats_functions.p8:5   const float  MAX_FLOAT = 1.7014118345e+38         ; bytes: 255,127,255,255,255
	; source: library:/prog8lib/shared_floats_functions.p8:6   const float  MIN_FLOAT = -1.7014118345e+38        ; bytes: 255,255,255,255,255
	; source: library:/prog8lib/cx16/syslib.p8:1558   sys {
	; source: library:/prog8lib/cx16/syslib.p8:1582   asmsub  set_irq(uword handler @AY) clobbers(A)  {

set_irq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1584   %asm {{
	    php
        sei
        sta  _vector
        sty  _vector+1
        lda  #<_irq_handler
        sta  cbm.CINV
        lda  #>_irq_handler
        sta  cbm.CINV+1
        lda  #1
        tsb  cx16.VERA_IEN      ; enable the vsync irq
        plp
        rts

_irq_handler
        jsr  sys.save_prog8_internals
        cld

        jsr  _run_custom
        pha
		jsr  sys.restore_prog8_internals
		pla
		beq  +
		jmp  (restore_irq._orig_irqvec)   ; continue with normal kernal irq routine
+		lda  #1
		sta  cx16.VERA_ISR      ; clear Vera Vsync irq status
		ply
		plx
		pla
		rti
_run_custom
		jmp  (_vector)
		.section BSS
_vector	.word ?
		.send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1623   asmsub  restore_irq() clobbers(A) {

restore_irq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1624   %asm {{
	    php
	    sei
	    lda  _orig_irqvec
	    sta  cbm.CINV
	    lda  _orig_irqvec+1
	    sta  cbm.CINV+1
	    lda  cx16.VERA_IEN
	    and  #%11110000     ; disable all Vera IRQs but the vsync
	    ora  #%00000001
	    sta  cx16.VERA_IEN
	    plp
	    rts
        .section BSS_NOCLEAR
_orig_irqvec    .word  ?
        .send BSS_NOCLEAR
        ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1644   asmsub  set_rasterirq(uword handler @AY, uword rasterpos @R0) clobbers(A) {

set_rasterirq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1646   %asm {{
	        php
            sei
            sta  user_vector
            sty  user_vector+1
            lda  cx16.r0
            ldy  cx16.r0+1
            lda  cx16.VERA_IEN
            and  #%11110000     ; disable all irqs but the line(raster) one
            ora  #%00000010
            sta  cx16.VERA_IEN
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  set_rasterline
            lda  #<_raster_irq_handler
            sta  cbm.CINV
            lda  #>_raster_irq_handler
            sta  cbm.CINV+1
            plp
            rts

_raster_irq_handler
            jsr  sys.save_prog8_internals
            cld
            jsr  _run_custom
            jsr  sys.restore_prog8_internals
            ; end irq processing - don't use kernal's irq handling
            lda  #2
            tsb  cx16.VERA_ISR      ; clear Vera line irq status
            ply
            plx
            pla
            rti
_run_custom
		    jmp  (user_vector)
		    .section BSS
user_vector	    .word ?
		    .send BSS

		    ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1689   asmsub update_rasterirq(uword handler @AY, uword rasterpos @R0) clobbers(A) {

update_rasterirq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1693   %asm {{
        php
        sei
        sta  sys.set_rasterirq.user_vector
        sty  sys.set_rasterirq.user_vector+1
        lda  cx16.r0L
        ldy  cx16.r0H
        jsr  set_rasterline
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1706   asmsub  set_rasterline(uword line @AY) {

set_rasterline	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1707   %asm {{
        php
        sei
        sta  cx16.VERA_IRQLINE_L
        tya
        lsr  a
        bcs  +
        lda  #%10000000
        trb  cx16.VERA_IEN
        plp
        rts
+       lda  #%10000000
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1725   asmsub reset_system() {

reset_system	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1729   %asm {{
            sei
-           ldx #$42
            ldy #2
            lda #0
            jsr  cx16.i2c_write_byte
            bra  -      ; to work around an issue where the routine does not in fact immediately reset the system
            ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1748   asmsub wait(uword jiffies @AY) clobbers(X) {

wait	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1752   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1

_loop       lda  P8ZP_SCRATCH_W1
            ora  P8ZP_SCRATCH_W1+1
            bne  +
            rts

+           php
            sei
            jsr  cbm.RDTIM
            plp
            sta  P8ZP_SCRATCH_B1
-           php
            sei
            jsr  cbm.RDTIM
            plp
            cmp  P8ZP_SCRATCH_B1
            beq  -

            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            bra  _loop
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1781   inline asmsub waitvsync()  {
	; source: library:/prog8lib/cx16/syslib.p8:1790   asmsub waitrasterline(uword line @AY) {

waitrasterline	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1792   %asm {{
            cpy  #0
            bne  _larger
-           cmp  cx16.VERA_SCANLINE_L
            bne  -
            bit  cx16.VERA_IEN
            bvs  -
            rts
_larger
            cmp  cx16.VERA_SCANLINE_L
            bne  _larger
            bit  cx16.VERA_IEN
            bvc  _larger
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1810   asmsub internal_stringcopy(str source @R0, str target @AY) clobbers (A,Y) {

internal_stringcopy	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1812   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1821   asmsub memcopy(uword source @R0, uword target @R1, uword count @AY) clobbers(A,X,Y) {

memcopy	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1827   %asm {{
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            dey
            beq  +
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            dey
            bne  -
+           lda  (cx16.r0),y
            sta  (cx16.r1),y
            rts

_longcopy
            pha                         ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            iny
            bne  -
            inc  cx16.r0+1
            inc  cx16.r1+1
            dex
            bne  -
            ply
            bne  _copyshort
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1866   asmsub memset(uword mem @R0, uword numbytes @R1, ubyte value @A) clobbers(A,X,Y) {

memset	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1867   %asm {{
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1878   asmsub memsetw(uword mem @R0, uword numwords @R1, uword value @AY) clobbers (A,X,Y) {

memsetw	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1879   %asm {{
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1892   asmsub memcmp(uword address1 @R0, uword address2 @R1, uword size @AY) -> byte @A {

memcmp	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1895   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldx  P8ZP_SCRATCH_W1+1
            beq  _no_msb_size

_loop_msb_size
            ldy  #0
-           lda  (cx16.r0),y
            cmp  (cx16.r1),y
            bcs  +
            lda  #-1
            rts
+           beq  +
            lda  #1
            rts
+           iny
            bne  -
            inc  cx16.r0+1
            inc  cx16.r1+1
            dec  P8ZP_SCRATCH_W1+1
            dex
            bne  _loop_msb_size

_no_msb_size
            lda  P8ZP_SCRATCH_W1
            bne  +
            rts

+           ldy  #0
-           lda  (cx16.r0),y
            cmp  (cx16.r1),y
            bcs  +
            lda  #-1
            rts
+           beq  +
            lda  #1
            rts
+           iny
            cpy  P8ZP_SCRATCH_W1
            bne  -

            lda #0
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1942   inline asmsub read_flags() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:1949   inline asmsub clear_carry() {
	; source: library:/prog8lib/cx16/syslib.p8:1955   inline asmsub set_carry() {
	; source: library:/prog8lib/cx16/syslib.p8:1961   inline asmsub clear_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1967   inline asmsub set_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1973   inline asmsub irqsafe_set_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1980   inline asmsub irqsafe_clear_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1986   inline asmsub disable_caseswitch() {
	; source: library:/prog8lib/cx16/syslib.p8:1993   inline asmsub enable_caseswitch() {
	; source: library:/prog8lib/cx16/syslib.p8:2000   asmsub save_prog8_internals() {

save_prog8_internals	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2001   %asm {{
            lda  P8ZP_SCRATCH_B1
            sta  save_SCRATCH_ZPB1
            lda  P8ZP_SCRATCH_REG
            sta  save_SCRATCH_ZPREG
            lda  P8ZP_SCRATCH_W1
            sta  save_SCRATCH_ZPWORD1
            lda  P8ZP_SCRATCH_W1+1
            sta  save_SCRATCH_ZPWORD1+1
            lda  P8ZP_SCRATCH_W2
            sta  save_SCRATCH_ZPWORD2
            lda  P8ZP_SCRATCH_W2+1
            sta  save_SCRATCH_ZPWORD2+1
            rts
            .section BSS
save_SCRATCH_ZPB1	.byte  ?
save_SCRATCH_ZPREG	.byte  ?
save_SCRATCH_ZPWORD1	.word  ?
save_SCRATCH_ZPWORD2	.word  ?
            .send BSS
            ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2025   asmsub restore_prog8_internals() {

restore_prog8_internals	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2026   %asm {{
            lda  save_prog8_internals.save_SCRATCH_ZPB1
            sta  P8ZP_SCRATCH_B1
            lda  save_prog8_internals.save_SCRATCH_ZPREG
            sta  P8ZP_SCRATCH_REG
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1
            sta  P8ZP_SCRATCH_W1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1+1
            sta  P8ZP_SCRATCH_W1+1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2
            sta  P8ZP_SCRATCH_W2
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2+1
            sta  P8ZP_SCRATCH_W2+1
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2043   asmsub exit(ubyte returnvalue @A) {

exit	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2045   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2053   asmsub exit2(ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y) {

exit2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2055   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            stx  p8_sys_startup.cleanup_at_exit._exitcodeX
            sty  p8_sys_startup.cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2065   asmsub exit3(ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y, bool carry @Pc) {

exit3	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2067   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            lda  #0
            rol  a
            sta  p8_sys_startup.cleanup_at_exit._exitcarry
            stx  p8_sys_startup.cleanup_at_exit._exitcodeX
            sty  p8_sys_startup.cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2080   inline asmsub progend() -> uword @AY {
	; source: library:/prog8lib/cx16/syslib.p8:2087   inline asmsub progstart() -> uword @AY {
	; source: library:/prog8lib/cx16/syslib.p8:2094   inline asmsub push(ubyte value @A) {
	; source: library:/prog8lib/cx16/syslib.p8:2100   inline asmsub pushw(uword value @AY) {
	; source: library:/prog8lib/cx16/syslib.p8:2107   inline asmsub push_returnaddress(uword address @XY) {
	; source: library:/prog8lib/cx16/syslib.p8:2119   asmsub get_as_returnaddress(uword address @XY) -> uword @AX {

get_as_returnaddress	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2120   %asm {{
            ; return the address like JSR would push onto the stack:  address-1,  MSB first then LSB
            cpx  #0
            bne  +
            dey
+           dex
            tya
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:2131   inline asmsub pop() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:2137   inline asmsub popw() -> uword @AY {
	; source: library:/prog8lib/cx16/syslib.p8:2144   inline asmsub pushl(long value @R0R1_32) {
	; source: library:/prog8lib/cx16/syslib.p8:2157   inline asmsub popl() -> long @R0R1_32 {
	; source: library:/prog8lib/cx16/syslib.p8:2170   asmsub cpu_is_65816() -> bool @A {

cpu_is_65816	.proc
	; source: library:/prog8lib/cx16/syslib.p8:2172   %asm {{
			php
			clv
			.byte $e2, $ea  ; SEP #$ea, should be interpreted as 2 NOPs by 6502. 65c816 will set the Overflow flag.
			bvc +
			lda #1
			plp
			rts
+			lda #0
			plp
			rts
	.pend
	.pend

; ---- block: 'conv' ----
conv	.proc
	; source: library:/prog8lib/conv.p8:3   conv {

; non-zeropage variables
	.section BSS
string_out	.fill  16
	.send BSS

	; source: library:/prog8lib/conv.p8:862   ubyte[16]  @shared string_out       ; internal result buffer for the string conversion routines (note: uses uninitialized ARRAY instead of STR, to force it to be allocated in BSS area so it's ROM-compatible)
	; source: library:/prog8lib/conv.p8:5   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/conv.p8:9   asmsub str_ub0(ubyte value @A) clobbers(X) -> str @AY {

str_ub0	.proc
	; source: library:/prog8lib/conv.p8:11   %asm {{
            jsr  internal_ubyte2decimal
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:24   asmsub str_ub(ubyte value @A) clobbers(X) -> str @AY {

str_ub	.proc
	; source: library:/prog8lib/conv.p8:26   %asm {{
            jsr  internal_ubyte2decimal
            cpy  #'0'
            beq  +
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            jmp  _done
+           cpx  #'0'
            beq  +
            stx  conv.string_out
            sta  conv.string_out+1
            lda  #0
            sta  conv.string_out+2
            jmp  _done
+           sta  conv.string_out
            lda  #0
            sta  conv.string_out+1
_done       lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:52   asmsub str_b(byte value @A) clobbers(X) -> str @AY {

str_b	.proc
	; source: library:/prog8lib/conv.p8:54   %asm {{
            cmp  #0
            bpl  str_ub
            eor  #255
            clc
            adc  #1
            jsr  str_ub
            ; insert a minus sign at the start
            lda  #0
            sta  conv.string_out+4
            lda  conv.string_out+2
            sta  conv.string_out+3
            lda  conv.string_out+1
            sta  conv.string_out+2
            lda  conv.string_out
            sta  conv.string_out+1
            lda  #'-'
            sta  conv.string_out
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:78   asmsub  str_ubhex  (ubyte value @ A) clobbers(X) -> str @AY {

str_ubhex	.proc
	; source: library:/prog8lib/conv.p8:80   %asm {{
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        lda  #0
        sta  string_out+2
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:92   asmsub  str_ubbin  (ubyte value @ A) clobbers(X) -> str @AY  {

str_ubbin	.proc
	; source: library:/prog8lib/conv.p8:94   %asm {{
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:113   asmsub  str_uwbin  (uword value @ AY) clobbers(X) -> str @AY  {

str_uwbin	.proc
	; source: library:/prog8lib/conv.p8:115   %asm {{
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out+8,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:136   asmsub  str_uwhex  (uword value @ AY) -> str @AY  {

str_uwhex	.proc
	; source: library:/prog8lib/conv.p8:138   %asm {{
        pha
        tya
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        pla
        jsr  internal_ubyte2hex
        sta  string_out+2
        sty  string_out+3
        lda  #0
        sta  string_out+4
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:180   asmsub  str_uw0  (uword value @ AY) clobbers(X) -> str @AY  {

str_uw0	.proc
	; source: library:/prog8lib/conv.p8:182   %asm {{
	    jsr  conv.internal_uword2decimal
	    ldy  #0
-       lda  conv.internal_uword2decimal.decTenThousands,y
        sta  string_out,y
        beq  +
        iny
        bne  -
+
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:197   asmsub  str_uw  (uword value @ AY) clobbers(X) -> str @AY  {

str_uw	.proc
	; source: library:/prog8lib/conv.p8:199   %asm {{
	    jsr  conv.internal_uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-       lda  internal_uword2decimal.decTenThousands,y
        beq  _allzero
        cmp  #'0'
        bne  _gotdigit
        iny
        bne  -
_gotdigit   sta  string_out,x
        inx
        iny
        lda  internal_uword2decimal.decTenThousands,y
        bne  _gotdigit
_end    lda  #0
        sta  string_out,x
        lda  #<string_out
        ldy  #>string_out
        rts

_allzero    lda  #'0'
        sta  string_out,x
        inx
        bne  _end
        ; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:229   asmsub  str_w  (word value @ AY) clobbers(X) -> str @AY  {

str_w	.proc
	; source: library:/prog8lib/conv.p8:231   %asm {{
	    cpy  #0
	    bpl  str_uw
	    pha
	    lda  #'-'
	    sta  string_out
        tya
        eor  #255
        tay
        pla
        eor  #255
        clc
        adc  #1
        bcc  +
        iny
+	    jsr  conv.internal_uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:332   asmsub  any2uword(str string @AY) -> uword @AY, ubyte @X {

any2uword	.proc
	; source: library:/prog8lib/conv.p8:338   %asm {{
	pha
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	ldy  P8ZP_SCRATCH_W1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        ldx  cx16.r15
        rts
	.pend
	; source: library:/prog8lib/conv.p8:363   inline asmsub  str2ubyte(str string @AY) clobbers(Y) -> ubyte @A {
	; source: library:/prog8lib/conv.p8:373   inline asmsub  str2byte(str string @AY) clobbers(Y) -> byte @A {
	; source: library:/prog8lib/conv.p8:383   asmsub  str2uword(str string @AY) -> uword @AY {

str2uword	.proc
	; source: library:/prog8lib/conv.p8:388   %asm {{
_result = P8ZP_SCRATCH_W1
        	sta  P8ZP_SCRATCH_W2
        	sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  P8ZP_SCRATCH_REG
		lda  _result
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  _result
		sta  _result
		lda  P8ZP_SCRATCH_REG
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend
	; source: library:/prog8lib/conv.p8:442   asmsub  str2word(str string @AY) -> word @AY {

str2word	.proc
	; source: library:/prog8lib/conv.p8:447   %asm {{
_result = P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (P8ZP_SCRATCH_W2),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
		.section BSS
_negative	.byte  ?
		.send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:504   asmsub  hex2uword(str string @AY) -> uword @AY {

hex2uword	.proc
	; source: library:/prog8lib/conv.p8:509   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:575   asmsub  bin2uword(str string @AY) -> uword @AY {

bin2uword	.proc
	; source: library:/prog8lib/conv.p8:579   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
	.pend
	; source: library:/prog8lib/conv.p8:615   asmsub internal_ubyte2decimal(ubyte value @A) -> ubyte @Y, ubyte @X, ubyte @A {

internal_ubyte2decimal	.proc
	; source: library:/prog8lib/conv.p8:616   %asm {{
        ldy  #'0'-1
        ldx  #'9'+1
        sec
-       iny
        sbc  #100
        bcs  -
-       dex
        adc  #10
        bmi  -
        adc  #'0'-1
        rts
	.pend
	; source: library:/prog8lib/conv.p8:631   asmsub  internal_uword2decimal  (uword value @AY) -> ubyte @Y, ubyte @A, ubyte @X  {

internal_uword2decimal	.proc
	; source: library:/prog8lib/conv.p8:637   %asm {{
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?p=130363&sid=1944ba8bac4d6afa9c02e3cc42304e6b#p130363

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2 @110/111
    beq    _useZero               ;2 @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2 @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2 @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2 @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

    .section BSS
decTenThousands   	.byte  ?
decThousands    	.byte  ?
decHundreds		.byte  ?
decTens			.byte  ?
decOnes   		.byte  ?
			.byte  ?		; zero-terminate the decimal output string, set to 0 by bss init mechanisms
    .send BSS
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:808   asmsub  internal_byte2decimal  (byte value @A) -> ubyte @Y, ubyte @A, ubyte @X  {

internal_byte2decimal	.proc
	; source: library:/prog8lib/conv.p8:811   %asm {{
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  internal_ubyte2decimal
	.pend
	; source: library:/prog8lib/conv.p8:821   asmsub  internal_ubyte2hex  (ubyte value @A) clobbers(X) -> ubyte @A, ubyte @Y  {

internal_ubyte2hex	.proc
	; source: library:/prog8lib/conv.p8:823   %asm {{
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:842   asmsub  internal_uword2hex  (uword value @AY) clobbers(A,Y)  {

internal_uword2hex	.proc
	; source: library:/prog8lib/conv.p8:844   %asm {{
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
		.section BSS
output		.fill 5      ; 0-terminated output buffer (to make printing easier)
		.send BSS
		; !notreached!
	.pend
	.pend

; ---- block: 'strings' ----
strings	.proc
	; source: library:/prog8lib/strings.p8:5   strings {


	; source: library:/prog8lib/strings.p8:6   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/strings.p8:8   asmsub length(str string @AY) clobbers(A) -> ubyte @Y {

length	.proc
	; source: library:/prog8lib/strings.p8:14   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:26   asmsub left(str source @AX, ubyte length @Y, str target @R1) clobbers(A, Y) {

left	.proc
	; source: library:/prog8lib/strings.p8:31   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		sta  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:53   asmsub right(str source @AY, ubyte length @X, str target @R1) clobbers(A,Y) {

right	.proc
	; source: library:/prog8lib/strings.p8:58   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		stx  P8ZP_SCRATCH_B1
		sta  cx16.r0
		sty  cx16.r0+1
		jsr  length
		tya
		sec
		sbc  P8ZP_SCRATCH_B1
		clc
		adc  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:92   asmsub slice(str source @R0, ubyte start @A, ubyte length @Y, str target @R1) clobbers(A, Y) {

slice	.proc
	; source: library:/prog8lib/strings.p8:98   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		sta  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1

		; adjust src location
		clc
		lda  P8ZP_SCRATCH_W1
		adc  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		beq  _startloop
-		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend
	; source: library:/prog8lib/strings.p8:130   asmsub find(str string @AY, ubyte character @X) -> ubyte @A, bool @Pc {

find	.proc
	; source: library:/prog8lib/strings.p8:133   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		stx  P8ZP_SCRATCH_B1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  P8ZP_SCRATCH_B1
		beq  _found
		iny
		bne  -
_notfound	lda  #255
        clc
		rts
_found	tya
        sec
        rts
	.pend
	; source: library:/prog8lib/strings.p8:155   asmsub find_eol(str string @AY) -> ubyte @A, bool @Pc {

find_eol	.proc
	; source: library:/prog8lib/strings.p8:159   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  #13
		beq  _found
		cmp  #10
		beq  _found
		iny
		bne  -
_notfound	lda  #255
        clc
		rts
_found	tya
        sec
        rts
	.pend
	; source: library:/prog8lib/strings.p8:181   asmsub rfind(str string @AY, ubyte character @X) -> ubyte @A, bool @Pc {

rfind	.proc
	; source: library:/prog8lib/strings.p8:184   %asm {{
            stx  P8ZP_SCRATCH_B1
            ; note: we make use of the fact that length() stores the string address AY in P8ZP_SCRATCH_W1 for us! we need that later
            jsr  length
            cpy  #0
            beq  _notfound
            dey
-           lda  (P8ZP_SCRATCH_W1),y
            cmp  P8ZP_SCRATCH_B1
            beq  _found
            dey
            cpy  #255
            bne  -
_notfound   lda  #255
            clc
            rts
_found      tya
            sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:206   asmsub contains(str string @AY, ubyte character @X) -> bool @Pc {

contains	.proc
	; source: library:/prog8lib/strings.p8:208   %asm {{
            jmp  find
	.pend
	; source: library:/prog8lib/strings.p8:213   asmsub copy(str source @R0, str target @AY) clobbers(A) -> ubyte @Y {

copy	.proc
	; source: library:/prog8lib/strings.p8:218   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/strings.p8:227   asmsub append(str target @R0, str suffix @R1) clobbers(Y) -> ubyte @A {

append	.proc
	; source: library:/prog8lib/strings.p8:230   %asm {{
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  length
            sty  P8ZP_SCRATCH_B1
            tya
            clc
            adc  cx16.r0
            sta  P8ZP_SCRATCH_W1
            lda  cx16.r0+1
            adc  #0
            sta  P8ZP_SCRATCH_W1+1
            lda  cx16.r1
            ldy  cx16.r1+1
            jsr  prog8_lib.strcpy
            tya
            clc
            adc  P8ZP_SCRATCH_B1
            rts
	.pend
	; source: library:/prog8lib/strings.p8:252   asmsub compare(str string1 @R0, str string2 @AY) clobbers(Y) -> byte @A {

compare	.proc
	; source: library:/prog8lib/strings.p8:257   %asm {{
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend
	; source: library:/prog8lib/strings.p8:266   asmsub ncompare(str string1 @R0, str string2 @AY, ubyte length @X) clobbers(X, Y) -> byte @A {

ncompare	.proc
	; source: library:/prog8lib/strings.p8:270   %asm {{
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strncmp_mem
	.pend
	; source: library:/prog8lib/strings.p8:279   asmsub lower(str st @AY) -> ubyte @Y {

lower	.proc
	; source: library:/prog8lib/strings.p8:283   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/strings.p8:302   asmsub upper(str st @AY) -> ubyte @Y {

upper	.proc
	; source: library:/prog8lib/strings.p8:304   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/strings.p8:322   asmsub lowerchar(ubyte character @A) -> ubyte @A {

lowerchar	.proc
	; source: library:/prog8lib/strings.p8:323   %asm {{
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:334   asmsub upperchar(ubyte character @A) -> ubyte @A {

upperchar	.proc
	; source: library:/prog8lib/strings.p8:335   %asm {{
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:345   asmsub pattern_match(str string @AY, str pattern @R0) clobbers(Y) -> bool @A {

pattern_match	.proc
	; source: library:/prog8lib/strings.p8:362   %asm {{
strptr = P8ZP_SCRATCH_W1

	sta  strptr
	sty  strptr+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	rol  a
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (strptr),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (strptr),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (strptr),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend
	; source: library:/prog8lib/strings.p8:421   asmsub hash(str string @AY) -> ubyte @A {

hash	.proc
	; source: library:/prog8lib/strings.p8:425   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            lda  #179
            sta  P8ZP_SCRATCH_REG
            ldy  #0
            clc
-           lda  (P8ZP_SCRATCH_W1),y
            beq  +
            rol  P8ZP_SCRATCH_REG
            eor  P8ZP_SCRATCH_REG
            sta  P8ZP_SCRATCH_REG
            iny
            bne  -
+           lda  P8ZP_SCRATCH_REG
            rts
	.pend
	; source: library:/prog8lib/strings.p8:444   asmsub isdigit(ubyte petsciichar @A) -> bool @Pc {

isdigit	.proc
	; source: library:/prog8lib/strings.p8:445   %asm {{
            cmp  #'0'
            bcs  +
            rts
+           cmp  #'9'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:458   asmsub isupper(ubyte petsciichar @A) -> bool @Pc {

isupper	.proc
	; source: library:/prog8lib/strings.p8:460   %asm {{
            cmp  #97
            bcs  +
            rts
+           cmp  #122+1
            bcc  _yes
            cmp  #193
            bcs  +
            rts
+           cmp  #218+1
            bcc  _yes
            clc
            rts
_yes        sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:478   asmsub islower(ubyte petsciichar @A) -> bool @Pc {

islower	.proc
	; source: library:/prog8lib/strings.p8:479   %asm {{
            cmp  #'a'
            bcs  +
            rts
+           cmp  #'z'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:492   asmsub isletter(ubyte petsciichar @A) -> bool @Pc {

isletter	.proc
	; source: library:/prog8lib/strings.p8:493   %asm {{
            jsr  islower
            bcc  isupper
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:501   asmsub isspace(ubyte petsciichar @A) -> bool @Pc {

isspace	.proc
	; source: library:/prog8lib/strings.p8:502   %asm {{
            cmp  #32
            beq  +
            cmp  #13
            beq  +
            cmp  #9
            beq  +
            cmp  #10
            beq  +
            cmp  #141
            beq  +
            cmp  #160
            beq  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:522   asmsub isprint(ubyte petsciichar @A) -> bool @Pc {

isprint	.proc
	; source: library:/prog8lib/strings.p8:523   %asm {{
            cmp  #160
            bcc  +
            rts
+           cmp  #32
            bcs  +
            rts
+           cmp  #128
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	.pend

; ---- block: 'floats' ----
floats	.proc
	; source: library:/prog8lib/cx16/floats.p8:6   floats {
	E = 2.718281828459045
	EPSILON = 2.938735878E-39
	PI = 3.141592653589793
	TWOPI = 6.283185307179586
	 = 3.141592653589793

	AYINT = $fe00
	GIVAYF = $fe03
	FOUT = $fe06
	VAL_1 = $fe09
	GETADR = $fe0c
	FLOATC = $fe0f
	FSUB = $fe12
	FSUBT = $fe15
	FADD = $fe18
	FADDT = $fe1b
	FMULT = $fe1e
	FMULTT = $fe21
	FDIV = $fe24
	FDIVT = $fe27
	LOG = $fe2a
	INT = $fe2d
	SQR = $fe30
	NEGOP = $fe33
	FPWR = $fe36
	FPWRT = $fe39
	EXP = $fe3c
	COS = $fe3f
	SIN = $fe42
	TAN = $fe45
	ATN = $fe48
	ROUND = $fe4b
	ABS = $fe4e
	SIGN = $fe51
	FCOMP = $fe54
	RND_0 = $fe57
	RND = $fe57
	CONUPK = $fe5a
	ROMUPK = $fe5d
	MOVFRM = $fe60
	MOVFM = $fe63
	MOVMF = $fe66
	MOVFA = $fe69
	MOVAF = $fe6c
	FADDH = $fe6f
	ZEROFC = $fe72
	NORMAL = $fe75
	NEGFAC = $fe78
	MUL10 = $fe7b
	DIV10 = $fe7e
	MOVEF = $fe81
	SGN = $fe84
	FLOAT = $fe87
	FLOATS = $fe8a
	QINT = $fe8d
	FINLOG = $fe90

	; source: library:/prog8lib/shared_floats_functions.p8:27   const float           = 3.141592653589793
	; source: library:/prog8lib/shared_floats_functions.p8:28   const float  PI        = 
	; source: library:/prog8lib/shared_floats_functions.p8:29   const float  TWOPI     = 2*
	; source: library:/prog8lib/shared_floats_functions.p8:30   const float  E         = 2.718281828459045
	; source: library:/prog8lib/shared_floats_functions.p8:31   const float  EPSILON   = 2.938735878e-39          ; bytes: 1,0,0,0,0
	; source: library:/prog8lib/cx16/floats.p8:6   floats {
	; source: library:/prog8lib/cx16/floats.p8:17   extsub $fe00 = AYINT() clobbers(A,X,Y)          ; fac1-> signed word in 'facmo' and 'faclo', MSB FIRST. DON'T USE THIS, USE WRAPPER 'AYINT2' INSTEAD.  (might throw ILLEGAL QUANTITY)

	; source: library:/prog8lib/cx16/floats.p8:22   extsub $fe03 = GIVAYF(ubyte lo @ Y, ubyte hi @ A) clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/floats.p8:24   extsub $fe06 = FOUT() clobbers(X) -> str @ AY             ; fac1 -> string, address returned in AY

	; source: library:/prog8lib/cx16/floats.p8:25   extsub $fe09 = VAL_1(str string @XY, ubyte length @A) clobbers(A,X,Y) -> float @FAC1      ; convert ASCII string in XY and length in A, to floating point in FAC1. WARNING: only implemented in ROM 47+. Safer to use floats.parse() instead.

	; source: library:/prog8lib/cx16/floats.p8:29   extsub $fe0c = GETADR() clobbers(X) -> ubyte @ Y, ubyte @ A

	; source: library:/prog8lib/cx16/floats.p8:30   extsub $fe0f = FLOATC() clobbers(A,X,Y)                     ; convert address to floating point

	; source: library:/prog8lib/cx16/floats.p8:32   extsub $fe12 = FSUB(uword mflpt @ AY) clobbers(A,X,Y)       ; fac1 = mflpt from A/Y - fac1

	; source: library:/prog8lib/cx16/floats.p8:33   extsub $fe15 = FSUBT() clobbers(A,X,Y)                      ; fac1 = fac2-fac1   mind the order of the operands

	; source: library:/prog8lib/cx16/floats.p8:34   extsub $fe18 = FADD(uword mflpt @ AY) clobbers(A,X,Y)       ; fac1 += mflpt value from A/Y

	; source: library:/prog8lib/cx16/floats.p8:35   extsub $fe1b = FADDT() clobbers(A,X,Y)                      ; fac1 += fac2

	; source: library:/prog8lib/cx16/floats.p8:36   extsub $fe1e = FMULT(uword mflpt @ AY) clobbers(A,X,Y)      ; fac1 *= mflpt value from A/Y

	; source: library:/prog8lib/cx16/floats.p8:37   extsub $fe21 = FMULTT() clobbers(A,X,Y)                     ; fac1 *= fac2

	; source: library:/prog8lib/cx16/floats.p8:38   extsub $fe24 = FDIV(uword mflpt @ AY) clobbers(A,X,Y)       ; fac1 = mflpt in A/Y / fac1

	; source: library:/prog8lib/cx16/floats.p8:39   extsub $fe27 = FDIVT() clobbers(A,X,Y)                      ; fac1 = fac2/fac1  mind the order of the operands

	; source: library:/prog8lib/cx16/floats.p8:40   extsub $fe2a = LOG() clobbers(A,X,Y)                        ; fac1 = LN(fac1)  (natural log)

	; source: library:/prog8lib/cx16/floats.p8:41   extsub $fe2d = INT() clobbers(A,X,Y)                        ; INT() truncates, use FADDH first to integer round instead of trunc

	; source: library:/prog8lib/cx16/floats.p8:42   extsub $fe30 = SQR() clobbers(A,X,Y)                        ; fac1 = SQRT(fac1)

	; source: library:/prog8lib/cx16/floats.p8:43   extsub $fe33 = NEGOP() clobbers(A)                          ; switch the sign of fac1 (fac1 = -fac1)

	; source: library:/prog8lib/cx16/floats.p8:44   extsub $fe36 = FPWR(uword mflpt @ AY) clobbers(A,X,Y)       ; fac1 = fac2 ** float in A/Y

	; source: library:/prog8lib/cx16/floats.p8:45   extsub $fe39 = FPWRT() clobbers(A,X,Y)                      ; fac1 = fac2 ** fac1

	; source: library:/prog8lib/cx16/floats.p8:46   extsub $fe3c = EXP() clobbers(A,X,Y)                        ; fac1 = EXP(fac1)  (e ** fac1)

	; source: library:/prog8lib/cx16/floats.p8:47   extsub $fe3f = COS() clobbers(A,X,Y)                        ; fac1 = COS(fac1)

	; source: library:/prog8lib/cx16/floats.p8:48   extsub $fe42 = SIN() clobbers(A,X,Y)                        ; fac1 = SIN(fac1)

	; source: library:/prog8lib/cx16/floats.p8:49   extsub $fe45 = TAN() clobbers(A,X,Y)                        ; fac1 = TAN(fac1)

	; source: library:/prog8lib/cx16/floats.p8:50   extsub $fe48 = ATN() clobbers(A,X,Y)                        ; fac1 = ATN(fac1)

	; source: library:/prog8lib/cx16/floats.p8:51   extsub $fe4b = ROUND() clobbers(A,X,Y)                      ; round least significant bit of fac1

	; source: library:/prog8lib/cx16/floats.p8:52   extsub $fe4e = ABS() clobbers(A,X,Y)                        ; fac1 = ABS(fac1)

	; source: library:/prog8lib/cx16/floats.p8:53   extsub $fe51 = SIGN() clobbers(X,Y) -> ubyte @ A            ; SIGN(fac1) to A, $ff, $0, $1 for negative, zero, positive

	; source: library:/prog8lib/cx16/floats.p8:54   extsub $fe54 = FCOMP(uword mflpt @ AY) clobbers(X,Y) -> ubyte @ A   ; A = compare fac1 to mflpt in A/Y, 0=equal 1=fac1 is greater, 255=fac1 is less than

	; source: library:/prog8lib/cx16/floats.p8:55   extsub $fe57 = RND_0() clobbers(A,X,Y)                      ; fac1 = RND(fac1) float random number generator  NOTE: incompatible with C64's RND routine

	; source: library:/prog8lib/cx16/floats.p8:56   extsub $fe57 = RND() clobbers(A,X,Y)                        ; alias for RND_0

	; source: library:/prog8lib/cx16/floats.p8:57   extsub $fe5a = CONUPK(uword mflpt @ AY) clobbers(A,X,Y)     ; load mflpt value from memory in A/Y into fac2

	; source: library:/prog8lib/cx16/floats.p8:58   extsub $fe5d = ROMUPK(uword mflpt @ AY) clobbers(A,X,Y)     ; load mflpt value from memory in current bank in A/Y into fac2

	; source: library:/prog8lib/cx16/floats.p8:59   extsub $fe60 = MOVFRM(uword mflpt @ AY) clobbers(A,X,Y)     ; load mflpt value from memory in A/Y into fac1  (use MOVFM instead)

	; source: library:/prog8lib/cx16/floats.p8:60   extsub $fe63 = MOVFM(uword mflpt @ AY) clobbers(A,X,Y)      ; load mflpt value from memory in A/Y into fac1

	; source: library:/prog8lib/cx16/floats.p8:61   extsub $fe66 = MOVMF(uword mflpt @ XY) clobbers(A,X,Y)      ; store fac1 to memory  X/Y as 5-byte mflpt

	; source: library:/prog8lib/cx16/floats.p8:62   extsub $fe69 = MOVFA() clobbers(A,X)                        ; copy fac2 to fac1

	; source: library:/prog8lib/cx16/floats.p8:63   extsub $fe6c = MOVAF() clobbers(A,X)                        ; copy fac1 to fac2  (rounded the least significant bit)

	; source: library:/prog8lib/cx16/floats.p8:66   extsub $fe6f = FADDH() clobbers(A,X,Y)                      ; fac1 += 0.5, for integer rounding- call this before INT

	; source: library:/prog8lib/cx16/floats.p8:67   extsub $fe72 = ZEROFC() clobbers(A,X,Y)                     ; fac1 = 0

	; source: library:/prog8lib/cx16/floats.p8:68   extsub $fe75 = NORMAL() clobbers(A,X,Y)                     ; normalize fac1

	; source: library:/prog8lib/cx16/floats.p8:69   extsub $fe78 = NEGFAC() clobbers(A)                         ; switch the sign of fac1 (fac1 = -fac1) (doesn't work, juse use NEGOP() instead!)

	; source: library:/prog8lib/cx16/floats.p8:70   extsub $fe7b = MUL10() clobbers(A,X,Y)                      ; fac1 *= 10

	; source: library:/prog8lib/cx16/floats.p8:71   extsub $fe7e = DIV10() clobbers(A,X,Y)                      ; fac1 /= 10 , CAUTION: result is always positive! Have to restore sign manually!

	; source: library:/prog8lib/cx16/floats.p8:72   extsub $fe81 = MOVEF() clobbers(A,X)                        ; copy fac1 to fac2

	; source: library:/prog8lib/cx16/floats.p8:73   extsub $fe84 = SGN() clobbers(A,X,Y)                        ; fac1 = SGN(fac1), result of SIGN (-1, 0 or 1)

	; source: library:/prog8lib/cx16/floats.p8:74   extsub $fe87 = FLOAT() clobbers(A,X,Y)                      ; FAC = (s8).A

	; source: library:/prog8lib/cx16/floats.p8:75   extsub $fe8a = FLOATS() clobbers(A,X,Y)                     ; FAC = (s16)facho+1:facho

	; source: library:/prog8lib/cx16/floats.p8:76   extsub $fe8d = QINT() clobbers(A,X,Y)                       ; facho:facho+1:facho+2:facho+3 = u32(FAC)

	; source: library:/prog8lib/cx16/floats.p8:77   extsub $fe90 = FINLOG(byte value @A) clobbers (A, X, Y)     ; fac1 += signed byte in A

	; source: library:/prog8lib/cx16/floats.p8:80   asmsub  AYINT2() clobbers(X) -> word @AY {

AYINT2	.proc
	; source: library:/prog8lib/cx16/floats.p8:83   %asm {{
		jsr  AYINT
		ldx  #<floats_temp_var
		ldy  #>floats_temp_var
		jsr  MOVMF
		lda  floats_temp_var+4
		ldy  floats_temp_var+3
        rts
	.pend
	; source: library:/prog8lib/cx16/floats.p8:94   asmsub  FREADSA  (byte value @A) clobbers(A,X,Y) {

FREADSA	.proc
	; source: library:/prog8lib/cx16/floats.p8:96   %asm {{
        tay
        bpl  +
        lda  #$ff
        jmp  GIVAYF
+       lda  #0
        jmp  GIVAYF
	.pend
	; source: library:/prog8lib/cx16/floats.p8:106   asmsub FREADU24AXY(ubyte lo @ A, ubyte mid @ X, ubyte hi @ Y) clobbers(A, X, Y) -> float @FAC1 {

FREADU24AXY	.proc
	; source: library:/prog8lib/cx16/floats.p8:108   %asm{{
                 FAC = $C3
                 sty FAC+1
                 stx FAC+2
                 sta FAC+3

                 cpy #$00
                 bne +
                 cpx #$00
                 bne +
                 cmp #$00
                 beq ++

              +  ldx #$98
                 bit FAC+1
                 bmi +

              -  dex
                 asl FAC+3
                 rol FAC+2
                 rol FAC+1
                 bpl -

               + stx FAC
                 stz FAC+4
                 stz FAC+5
                 rts
	.pend
	; source: library:/prog8lib/cx16/floats.p8:138   asmsub  GIVUAYFAY  (uword value @ AY) clobbers(A,X,Y)  {

GIVUAYFAY	.proc
	; source: library:/prog8lib/cx16/floats.p8:142   %asm {{
	sty  $c4        ; facmo
	sta  $c5        ; facmo+1
	ldx  #$90
	sec
	jmp  FLOATC
	.pend
	; source: library:/prog8lib/cx16/floats.p8:151   asmsub  GIVAYFAY  (uword value @ AY) clobbers(A,X,Y)  {

GIVAYFAY	.proc
	; source: library:/prog8lib/cx16/floats.p8:153   %asm {{
		sta  P8ZP_SCRATCH_B1
		tya
		ldy  P8ZP_SCRATCH_B1
		jmp  GIVAYF		; this uses the inverse order, Y/A
	.pend
	; source: library:/prog8lib/cx16/floats.p8:161   asmsub  GETADRAY  () clobbers(X) -> uword @ AY  {

GETADRAY	.proc
	; source: library:/prog8lib/cx16/floats.p8:163   %asm {{
		jsr  GETADR		; this uses the inverse order, Y/A
		sta  P8ZP_SCRATCH_B1
		tya
		ldy  P8ZP_SCRATCH_B1
		rts
	.pend
	; source: library:/prog8lib/cx16/floats.p8:172   asmsub  FREADUY (ubyte value @Y) {

FREADUY	.proc
	; source: library:/prog8lib/cx16/floats.p8:174   %asm {{
        lda  #0
        jmp  GIVAYF
	.pend
	; source: library:/prog8lib/cx16/floats.p8:180   asmsub parse(str value @AY) -> float @FAC1 {

parse	.proc
	; source: library:/prog8lib/cx16/floats.p8:183   %asm {{
        ldx  VAL_1
        cpx  #$4c       ; is there an implementation in VAL_1? (test for JMP)
        bne  _borked    ; no, print error message
        pha             ; yes, count the length and call rom VAL_1.
        phy
        jsr  prog8_lib.strlen
        tya
        ply
        plx
        jmp  VAL_1
_borked
        ldy  #0
-       lda  _msg,y
        beq  +
        jsr  cbm.CHROUT
        iny
        bne  -
+       jmp  sys.exit

_msg    .text 13,"?rom 47+ required for val1",13,0
        ; !notreached!
	.pend
	; source: library:/prog8lib/cx16/floats.p8:216   asmsub normalize(float value @FAC1) -> float @ FAC1 {

normalize	.proc
	; source: library:/prog8lib/cx16/floats.p8:217   %asm {{
        jmp  floats.NORMAL
	.pend
	; source: library:/prog8lib/cx16/floats.p8:223   asmsub time() -> float @ FAC1 {

time	.proc
	; source: library:/prog8lib/cx16/floats.p8:224   %asm {{
        jsr cbm.RDTIM
        jmp floats.FREADU24AXY
	.pend
	; source: library:/prog8lib/cx16/floats.p8:230   %asminclude "library:c64/floats.asm"
; --- low level floating point assembly routines for the C64

FL_ONE_const	.byte  129     			; 1.0
FL_ZERO_const	.byte  0,0,0,0,0		; 0.0
FL_LOG2_const	.byte  $80, $31, $72, $17, $f8	; log(2)

		.section BSS
floats_temp_var         .byte  ?,?,?,?,?        ; temporary storage for a float
		.send BSS

ub2float	.proc
		; -- convert ubyte in SCRATCH_ZPB1 to float at address A/Y
		;    clobbers A, X, Y
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		jsr  GIVAYF
_fac_to_mem	ldx  P8ZP_SCRATCH_W2
		ldy  P8ZP_SCRATCH_W2+1
		jmp  MOVMF
		.pend

b2float		.proc
		; -- convert byte in SCRATCH_ZPB1 to float at address A/Y
		;    clobbers A, X, Y
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_B1
		jsr  FREADSA
		jmp  ub2float._fac_to_mem
		.pend

uw2float	.proc
		; -- convert uword in SCRATCH_ZPWORD1 to float at address A/Y
		;    clobbers X
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1
		ldy  P8ZP_SCRATCH_W1+1
		jsr  GIVUAYFAY
		jmp  ub2float._fac_to_mem
		.pend

w2float		.proc
		; -- convert word in SCRATCH_ZPWORD1 to float at address A/Y
		;    clobbers X
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		jsr  GIVAYF
		jmp  ub2float._fac_to_mem
		.pend


cast_from_uw	.proc
		; -- uword in A/Y into float var at (P8ZP_SCRATCH_W2)
		;    clobbers X
		jsr  GIVUAYFAY
		jmp  ub2float._fac_to_mem
		.pend


cast_from_w	.proc
		; -- word in A/Y into float var at (P8ZP_SCRATCH_W2)
		;    clobbers X
		jsr  GIVAYFAY
		jmp  ub2float._fac_to_mem
		.pend


cast_from_ub	.proc
		; -- ubyte in Y into float var at (P8ZP_SCRATCH_W2)
		;    clobbers X
		jsr  FREADUY
		jmp  ub2float._fac_to_mem
		.pend


cast_from_b	.proc
		; -- byte in A into float var at (P8ZP_SCRATCH_W2)
		;    clobbers X
		jsr  FREADSA
		jmp  ub2float._fac_to_mem
		.pend

cast_as_uw_into_ya	.proc               ; also used for float 2 ub
		; -- cast float at A/Y to uword into Y/A
		;    clobbers X
		jsr  MOVFM
		jmp  cast_FAC1_as_uw_into_ya
		.pend

cast_as_w_into_ay	.proc               ; also used for float 2 b
		; -- cast float at A/Y to word into A/Y
		;    clobbers X
		jsr  MOVFM
		jmp  cast_FAC1_as_w_into_ay
		.pend

cast_as_bool_into_a	.proc
		; -- cast float at A/Y to bool into A
		;    clobbers X
		jsr  MOVFM
		jmp  cast_FAC1_as_bool_into_a
		.pend

cast_FAC1_as_bool_into_a	.proc
		; -- cast fac1 to bool into A
		;    clobbers X
		jsr  SIGN
		and  #1
		rts
		.pend

cast_FAC1_as_uw_into_ya	.proc               ; also used for float 2 ub
		; -- cast fac1 to uword into Y/A
		;    clobbers X
		jmp  GETADR     ; into Y/A
		.pend

cast_FAC1_as_w_into_ay	.proc               ; also used for float 2 b
		; -- cast fac1 to word into A/Y.  clobbers X
		jmp  AYINT2
		.pend


copy_float	.proc
		; -- copies the 5 bytes of the mflt value pointed to by P8ZP_SCRATCH_W1,
		;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

copy_float2	.proc
		; -- copies the 5 bytes of the mflt value pointed to by P8ZP_SCRATCH_W2,
		;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

inc_var_f	.proc
		; -- add 1 to float pointed to by A/Y
		;    clobbers X
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		jsr  MOVFM
		lda  #<FL_ONE_const
		ldy  #>FL_ONE_const
		jsr  FADD
		ldx  P8ZP_SCRATCH_W1
		ldy  P8ZP_SCRATCH_W1+1
		jmp  MOVMF
		.pend

dec_var_f	.proc
		; -- subtract 1 from float pointed to by A/Y
		;    clobbers X
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  #<FL_ONE_const
		ldy  #>FL_ONE_const
		jsr  MOVFM
		lda  P8ZP_SCRATCH_W1
		ldy  P8ZP_SCRATCH_W1+1
		jsr  FSUB
		ldx  P8ZP_SCRATCH_W1
		ldy  P8ZP_SCRATCH_W1+1
		jmp  MOVMF
		.pend

		.section BSS
fmath_float1	.byte ?,?,?,?,?	; storage for a mflpt5 value
fmath_float2	.byte ?,?,?,?,?	; storage for a mflpt5 value
		.send BSS

var_fac1_less_f	.proc
		; -- is the float in FAC1 < the variable AY? Result in A. Clobbers X.
		jsr  FCOMP
		cmp  #255
		beq  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

var_fac1_lesseq_f	.proc
		; -- is the float in FAC1 <= the variable AY?  Result in A. Clobbers X.
		jsr  FCOMP
		cmp  #0
		beq  +
		cmp  #255
		beq  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

var_fac1_greater_f	.proc
		; -- is the float in FAC1 > the variable AY?  Result in A. Clobbers X.
		jsr  FCOMP
		cmp  #1
		beq  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

var_fac1_greatereq_f	.proc
		; -- is the float in FAC1 >= the variable AY?  Result in A. Clobbers X.
		jsr  FCOMP
		cmp  #0
		beq  +
		cmp  #1
		beq  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

var_fac1_equal_f	.proc
		; -- are the floats numbers in FAC1 and the variable AY identical?   Result in A. Clobbers X.
		jsr  FCOMP
		and  #1
		eor  #1
		rts
		.pend

var_fac1_notequal_f	.proc
		; -- are the floats numbers in FAC1 and the variable AY *not* identical?   Result in A. Clobbers X.
		jsr  FCOMP
		and  #1
		rts
		.pend

vars_equal_f	.proc
		; -- are the mflpt5 numbers in P8ZP_SCRATCH_W1 and AY identical?  Result in A
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _false
		iny
		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _false
		iny
		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _false
		iny
		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _false
		iny
		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _false
		lda  #1
		rts
_false		lda  #0
		rts
		.pend


vars_less_f	.proc
		; -- is float in AY < float in P8ZP_SCRATCH_W2 ?   Result in A. Clobbers X.
		jsr  MOVFM
		lda  P8ZP_SCRATCH_W2
		ldy  P8ZP_SCRATCH_W2+1
		jsr  FCOMP
		cmp  #255
		bne  +
		lda  #1
		rts
+		lda  #0
		rts
		.pend

vars_lesseq_f	.proc
		; -- is float in AY <= float in P8ZP_SCRATCH_W2 ?  Result in A. Clobbers X.
		jsr  MOVFM
		lda  P8ZP_SCRATCH_W2
		ldy  P8ZP_SCRATCH_W2+1
		jsr  FCOMP
		cmp  #255
		bne  +
-		lda  #1
		rts
+		cmp  #0
		beq  -
		lda  #0
		rts
		.pend

less_f		.proc
		; -- is f1 < f2?    Result in A. Clobbers X.
		jsr  compare_floats
		cmp  #255
		beq  compare_floats._return_true
		bne  compare_floats._return_false
		.pend


lesseq_f	.proc
		; -- is f1 <= f2?  Result in A. Clobbers X.
		jsr  compare_floats
		cmp  #255
		beq  compare_floats._return_true
		cmp  #0
		beq  compare_floats._return_true
		bne  compare_floats._return_false
		.pend

greater_f	.proc
		; -- is f1 > f2?  Result in A. Clobbers X.
		jsr  compare_floats
		cmp  #1
		beq  compare_floats._return_true
		bne  compare_floats._return_false
		.pend

greatereq_f	.proc
		; -- is f1 >= f2?  Result in A. Clobbers X.
		jsr  compare_floats
		cmp  #1
		beq  compare_floats._return_true
		cmp  #0
		beq  compare_floats._return_true
		bne  compare_floats._return_false
		.pend

set_array_float_from_fac1	.proc
		; -- set the float in FAC1 in the array (index in A, array in P8ZP_SCRATCH_W1)
		;    clobbers X
		sta  P8ZP_SCRATCH_B1
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_B1
		ldy  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W1
		bcc  +
		iny
+		tax
		jmp  MOVMF
		.pend


set_0_array_float	.proc
		; -- set a float in an array to zero (index in A, array in P8ZP_SCRATCH_W1)
		sta  P8ZP_SCRATCH_B1
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_B1
		tay
		lda  #0
		sta  (P8ZP_SCRATCH_W1),y
		iny
		sta  (P8ZP_SCRATCH_W1),y
		iny
		sta  (P8ZP_SCRATCH_W1),y
		iny
		sta  (P8ZP_SCRATCH_W1),y
		iny
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend


set_array_float		.proc
		; -- set a float in an array to a value (index in A, float in P8ZP_SCRATCH_W1, array in P8ZP_SCRATCH_W2)
		sta  P8ZP_SCRATCH_B1
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_W2
		ldy  P8ZP_SCRATCH_W2+1
		bcc  +
		iny
+		jmp  copy_float
			; -- copies the 5 bytes of the mflt value pointed to by SCRATCH_ZPWORD1,
			;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
		.pend


pushFAC1    .proc
	;-- push floating point in FAC onto the cpu stack
	; save return address
	pla
	sta  P8ZP_SCRATCH_W2
	pla
	sta  P8ZP_SCRATCH_W2+1
	ldx  #<floats.floats_temp_var
	ldy  #>floats.floats_temp_var
	jsr  floats.MOVMF
	lda  floats.floats_temp_var
	pha
	lda  floats.floats_temp_var+1
	pha
	lda  floats.floats_temp_var+2
	pha
	lda  floats.floats_temp_var+3
	pha
	lda  floats.floats_temp_var+4
	pha
	; re-push return address
	lda  P8ZP_SCRATCH_W2+1
	pha
	lda  P8ZP_SCRATCH_W2
	pha
	rts
	.pend

popFAC .proc
	; -- pop floating point value from cpu stack into FAC1 or FAC2 (
	;    carry flag clear=FAC1, carry set=FAC2
	; save return address
	pla
	sta  P8ZP_SCRATCH_W2
	pla
	sta  P8ZP_SCRATCH_W2+1
	pla
	sta  floats.floats_temp_var+4
	pla
	sta  floats.floats_temp_var+3
	pla
	sta  floats.floats_temp_var+2
	pla
	sta  floats.floats_temp_var+1
	pla
	sta  floats.floats_temp_var
	lda  #<floats.floats_temp_var
	ldy  #>floats.floats_temp_var
	bcs  +
	jsr  floats.MOVFM
	jmp  ++
+       jsr  floats.CONUPK
+	; re-push return address
	lda  P8ZP_SCRATCH_W2+1
	pha
	lda  P8ZP_SCRATCH_W2
	pha
	rts
	.pend
	; source: library:/prog8lib/cx16/floats.p8:231   %asminclude "library:c64/floats_funcs.asm"
; --- floating point builtin functions


func_sign_f_into_A	.proc
		jsr  MOVFM
		jmp  SIGN
		.pend


a_times_5	.proc
		sta  P8ZP_SCRATCH_B1
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_B1
		rts
		.pend

func_abs_f_into_FAC1    .proc
        jsr  MOVFM
        jmp  ABS
	.pend

func_sqrt_into_FAC1     .proc
        jsr  MOVFM
        jmp  SQR
	.pend



containment_floatarray    .proc
	; -- check if a value exists in a float array.
	;    parameters: FAC1: value to check, P8ZP_SCRATCH_W1: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
	sty  P8ZP_SCRATCH_REG
	ldx  #<floats.floats_temp_var
	ldy  #>floats.floats_temp_var
	jsr  floats.MOVMF
	ldx  P8ZP_SCRATCH_REG
	ldy  #0
-       lda  floats.floats_temp_var
	cmp  (P8ZP_SCRATCH_W1),y
	bne  _firstmiss
	iny
	lda  floats.floats_temp_var+1
	cmp  (P8ZP_SCRATCH_W1),y
	bne  _secondmiss
	iny
	lda  floats.floats_temp_var+2
	cmp  (P8ZP_SCRATCH_W1),y
	bne  _thirdmiss
	iny
	lda  floats.floats_temp_var+3
	cmp  (P8ZP_SCRATCH_W1),y
	bne  _fourthmiss
	iny
	lda  floats.floats_temp_var+4
	cmp  (P8ZP_SCRATCH_W1),y
	bne  _fifthmiss
	lda  #1
	rts

_firstmiss
	iny
_secondmiss
	iny
_thirdmiss
	iny
_fourthmiss
	iny
_fifthmiss
        iny
	dex
	bne  -
        lda  #0
        rts

	.pend
	; source: library:/prog8lib/shared_floats_functions.p8:34   asmsub print(float value @FAC1) clobbers(A,X,Y) {

print	.proc
	; source: library:/prog8lib/shared_floats_functions.p8:36   %asm {{
	    jsr  tostr
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		jsr  cbm.CHROUT
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/shared_floats_functions.p8:48   asmsub tostr(float value @FAC1) clobbers(X) -> str @AY {

tostr	.proc
	; source: library:/prog8lib/shared_floats_functions.p8:50   %asm {{
        jsr  FOUT
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #' '
		bne  +
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W1
		ldy  P8ZP_SCRATCH_W1+1
		rts
	.pend
	; source: library:/prog8lib/shared_floats_functions.p8:270   inline asmsub push(float value @FAC1) {
	; source: library:/prog8lib/shared_floats_functions.p8:276   inline asmsub pop() -> float @FAC1 {
	.pend

; ---- block: 'prog8_math' ----
prog8_math	.proc
	; source: library:/prog8lib/prog8_math.p8:1   prog8_math {


	; source: library:/prog8lib/prog8_math.p8:2   %option no_symbol_prefixing
	; source: library:/prog8lib/prog8_math.p8:4   %asminclude "library:math.asm"
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	https://codebase64.net/doku.php?id=base:6502_6510_maths
;       https://github.com/TobyLobster/multiply_test
;       https://github.com/TobyLobster/sqrt_test


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
	; https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a

_multiplicand    = P8ZP_SCRATCH_B1
_multiplier      = P8ZP_SCRATCH_REG

    sty  _multiplicand
    lsr  a
    sta  _multiplier
    lda  #0
    ldx  #2
-
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier

    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    dex
    bne  -
    ; tay       ; if you want 16 bits result in AY, enable this again
    lda  _multiplier
    rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (UNSIGNED)
	;      input: A/Y = first 16-bit number, multiply_words.multiplier = second 16-bit number
	;      output: multiply_words.result, 4-bytes/32-bits product, LSB order (low-to-high)  low 16 bits also in AY.
	;      you can retrieve the upper 16 bits via math.mul16_last_upper()

	; NOTE FOR NEGATIVE VALUES:
	;      The routine also works for NEGATIVE (signed) word values, but ONLY the lower 16 bits of the result are correct then!
	;      Prog8 only uses those so that's not an issue, but math.mul16_last_upper() no longer gives the correct result here.

; mult62.a
; from: https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a
; based on Dr Jefyll, http://forum.6502.org/viewtopic.php?f=9&t=689&start=0#p19958
; - adjusted to use fixed zero page addresses
; - removed 'decrement to avoid clc' as this is slower on average
; - rearranged memory use to remove final memory copy and give LSB first order to result
; - removed temp zp storage bytes
; - unrolled the outer loop
; - unrolled the two inner loops once
;
; 16 bit x 16 bit unsigned multiply, 32 bit result
; Average cycles: ~442 ?
; 93 bytes

_multiplicand    = P8ZP_SCRATCH_W2   ; 2 bytes
multiplier      = result

; 16 bit x 16 bit unsigned multiply, 32 bit result
;
; On Entry:
;   (multiplier, multiplier+1): two byte multiplier, four bytes needed for result
;   (multiplicand, multiplicand+1): two byte multiplicand
; On Exit:
;   (result, result+1, result+2, result+3): product

    sta  _multiplicand
    sty  _multiplicand+1

    lda  #0              ;
    sta  result+2        ; 16 bits of zero in A, result+2
                        ;  Note:    First 8 shifts are  A -> result+2 -> result
                        ;           Final 8 shifts are  A -> result+2 -> result+1

    ; --- 1st byte ---
    ldy  #4              ; count for inner loop
    lsr  result

    ; inner loop (8 times)
_inner_loop
    ; first time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result

    ; second time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                 ; shift
    ror  result+2
    ror  result

    dey
    bne  _inner_loop      ; go back for 1 more shift?

    ; --- 2nd byte ---
    ldy  #4              ; count for inner loop
    lsr  result+1

    ; inner loop (8 times)
_inner_loop2
    ; first time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1

    ; second time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1
    dey
    bne  _inner_loop2     ; go back for 1 more shift?

    sta  result+3        ; ms byte of hi-word of result

    lda  result
    ldy  result+1
    rts

		.section BSS
result		.byte  ?,?,?,?       ; routine could be faster if this were in Zeropage...
		.send BSS
		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
		.section BSS
_remainder	.byte  ?
		.send BSS
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		rts
		.pend

remainder_ub_asm        .proc
		; -- divide A by Y, returns remainder in A   (unsigned)
		;    division by zero will result in just the original number.
		;    This routine specialcases 0,1,2 and otherwise is just a repeated subtraction.
		cpy  #0
		beq  _zero
		cpy  #1
		bne  +
		lda  #0
		rts
+		cpy  #2
		bne  +
		and  #1
		rts
+		sty  P8ZP_SCRATCH_REG
		sec
-		sbc  P8ZP_SCRATCH_REG
		bcs  -
		adc  P8ZP_SCRATCH_REG
_zero		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident

dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		rts
		.section BSS
_divisor	.word ?
		.send BSS
		.pend

randword	.proc
	; -- 16 bit pseudo random number generator into AY
	;    default seed = $00c2 $1137.  NOTE:  uses self-modifying code so won't work in ROM (use randword_rom instead)
        ;    routine from https://codebase64.net/doku.php?id=6502_6510_maths:x_abc_random_number_generator_8_16_bit
		inc x1
		clc
x1=*+1
		lda #$00	;x1
c1=*+1
		eor #$c2	;c1
a1=*+1
		eor #$11	;a1
		sta a1
b1=*+1
		adc #$37	;b1
		sta b1
		lsr a
		eor a1
		adc c1
		sta c1
		ldy b1
		rts
		.pend

randword_rom	.proc
	; -- 16 bit pseudo random number generator into AY. Can run from ROM.
	;    NOTE: you have to set the initial seed using randseed_rom! (a good default seed = $00c2 $1137)
        ;    routine from https://codebase64.net/doku.php?id=6502_6510_maths:x_abc_random_number_generator_8_16_bit
		inc  _x1
		clc
		lda  _x1
		eor  _c1
		eor  _a1
		sta  _a1
		adc  _b1
		sta  _b1
		lsr  a
		eor  _a1
		adc  _c1
		sta  _c1
		ldy  _b1
		rts
		.section BSS
_x1      .byte  ?
_c1      .byte  ?
_a1      .byte  ?
_b1      .byte  ?
		.send BSS
		.pend

randbyte = randword             ; -- 8 bit pseudo random number generator into A (by just reusing randword) NOTE: can not run from ROM
randbyte_rom = randword_rom     ; -- 8 bit pseudo random number generator into A (by just reusing randword). Can run from ROM


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y
		cpy  #0
		beq  +
		cmp  #0
		bpl  lsr_ubyte_A
-       	sec
		ror  a
		dey
		bne  -
+		rts
		.pend

lsr_ubyte_A	.proc
		; -- lsr unsigned byte in A times the value in Y
		cpy  #0
		beq  +
-		lsr  a
		dey
		bne  -
+		rts
		.pend

asl_byte_A      .proc
		; -- asl any byte in A times the value in Y
		cpy  #0
		beq  +
-		asl  a
		dey
		bne  -
+		rts
		.pend


lsr_word_AY     .proc
		; -- lsr signed word in AY times the value in X
		cpx  #0
		beq  +
		cpy  #0
		bpl  lsr_uword_AY
		sty  P8ZP_SCRATCH_B1
-		sec
		ror  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

lsr_uword_AY    .proc
		; -- lsr unsigned word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-		lsr  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

asl_word_AY     .proc
		; -- asl any word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-               asl  a
		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend


square          .proc
; -- calculate square of signed word (actually -255..255) in AY, result in AY
; routine by Lee Davison, source: http://6502.org/source/integers/square.htm
; using this routine is a lot faster as doing a regular multiplication (for words)
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	rts

		.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	; source: library:/prog8lib/prog8_lib.p8:3   prog8_lib {


	; source: library:/prog8lib/prog8_lib.p8:4   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/prog8_lib.p8:6   %asminclude "library:prog8_lib.asm"
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.

		.section BSS_NOCLEAR
orig_stackpointer	.byte  ?	; stores the Stack pointer register at program start
		.send BSS_NOCLEAR

program_startup_clear_bss    .proc
	; this is always ran first thing from the start routine to clear out the BSS area
	.if  prog8_bss_section_size>0
		; reset all variables in BSS section to zero
		lda  #<prog8_bss_section_start
		ldy  #>prog8_bss_section_start
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldx  #<prog8_bss_section_size
		ldy  #>prog8_bss_section_size
		lda  #0
		jsr  prog8_lib.memset
	.endif
		rts
		.pend



read_byte_from_address_in_AY_into_A	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend

read_byte_from_address_in_AY_into_A_65c02	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  (P8ZP_SCRATCH_W2)
		rts
		.pend


write_byte_X_to_address_in_AY	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		txa
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

write_byte_X_to_address_in_AY_65c02	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		txa
		sta  (P8ZP_SCRATCH_W2)
		rts
		.pend


reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend


memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		ldy  #0
		ldx  P8ZP_SCRATCH_REG
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _val
		sty  _val+1
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
		lda  _val
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		lda  _val+1
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
		lda  _val
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  _val+1
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.section BSS
_val	.word ?
		.send BSS
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
		.section BSS
_arg_s1		.word  ?
_arg_s2		.word  ?
		.send BSS
		.pend

strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depending on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop           lda  (P8ZP_SCRATCH_W1),y
		beq  _c1_zero
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _equal
		bmi  _less
		lda  #1
		rts
_less           lda  #-1
		rts
_equal          iny
		bne  _loop
_c1_zero        lda  (P8ZP_SCRATCH_W2),y
		beq  +
		lda  #-1
+		rts
		.pend

strncmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
                ;      Compares up to maximum length specified in X.
		;      Returns -1,0,1 in A, depending on the ordering. Clobbers X & Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop           lda  (P8ZP_SCRATCH_W1),y
		beq  _c1_zero
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _equal
		bmi  _less
		lda  #1
		rts
_less           lda  #-1
		rts
_equal          dex
		bne +
		lda #0
		rts
+		iny
		bne  _loop
_c1_zero        lda  (P8ZP_SCRATCH_W2),y
		beq  +
		lda  #-1
+		rts
		.pend


strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y. Clobbers A.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_linearwordarray	.proc
	; -- check if a value exists in a linear word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = number of elements in the array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
		dey
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend

containment_splitwordarray	.proc
	; -- check if a value exists in a split lsb/msb word array. (Assuming lsb array comes first, immediately followed by msb array)
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: start address of the lsb word array, Y = number of elements in the array (>=1).
	;    returns boolean 0/1 in A.

	; store the needle value in SCRATCH_B1(lsb) and SCRATCH_REG(msb)
		lda  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_REG

	; calculate where the msb array starts and put this in P8ZP_SCRATCH_W1  (_W2 is the start of the lsb array)
		tya
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W2+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1

	; search needle
		dey
-               lda  P8ZP_SCRATCH_REG
		cmp  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  P8ZP_SCRATCH_B1
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
+               dey
		cpy  #255
		bne  -
		lda  #0
		rts
_found          lda  #1
		rts
	.pend


memcopy_small   .proc
		; copy up to a single page (256 bytes) of memory.
		; note: only works for NON-OVERLAPPING memory regions!
		; P8ZP_SCRATCH_W1 = from address
		; P8ZP_SCRATCH_W2 = destination address
		; Y = number of bytes to copy  (where 0 means 256)
		cpy  #0
		beq  _fullpage
		dey
		beq  _lastbyte
_loop           lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _loop
_lastbyte       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                rts
_fullpage       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _fullpage
                rts
		.pend


long_not_equals     .proc
		; checks if the 32 bits long value pointed to by AY is NOT equal to the one pointed to by P8ZP_SCRATCH_W1
		; returns A=1 if NOT equals otherwise A=0
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #3
-		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _notequal
		dey
		bpl  -
		lda  #0
		rts
_notequal       lda  #1
		rts
		.pend


long_add_inplace        .proc
		; long pointed to by AY += long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		clc
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_sub_inplace    .proc
		; long pointed to by AY -= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sec
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_or_inplace       .proc
		; long pointed to by AY OR= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_and_inplace       .proc
		; long pointed to by AY AND= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_xor_inplace       .proc
		; long pointed to by AY XOR= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_shiftleftX_inplace         .proc
		; bit shift left X bits the long value pointed to by AY
		cpx  #0
		beq  _end
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
-		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		asl  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		dex
		bne  -
_end		rts
		.pend

long_shiftrightX_inplace        .proc
		; bit shift right X bits the long value pointed to by AY
		cpx  #0
		beq  _end
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
-		ldy  #3
		lda  (P8ZP_SCRATCH_W1),y
		asl  a  ; save sign bit
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dex
		bne  -
_end		rts
		.pend
	; source: library:/prog8lib/prog8_lib.p8:7   %asminclude "library:prog8_funcs.asm"
; ---- builtin functions

abs_b_into_A	.proc
	; -- A = abs(A)
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

abs_l_into_R14R15	.proc
	; -- R14:R15 = abs(R14:R15)
    lda  cx16.r15H
    bmi  +   ; Negative if high bit of highest byte is set
    rts
+
    ; Invert all four bytes
    lda  cx16.r14L
    eor  #$FF
    sta  cx16.r14L
    lda  cx16.r14H
    eor  #$FF
    sta  cx16.r14H
    lda  cx16.r15L
    eor  #$FF
    sta  cx16.r15L
    lda  cx16.r15H
    eor  #$FF
    sta  cx16.r15H
    ; Add 1 to whole 32-bit value
    inc  cx16.r14L
    bne  +
    inc  cx16.r14H
    bne  +
    inc  cx16.r15L
    bne  +
    inc  cx16.r15H
+   rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		bmi  _negative
		bne  _positive
		cmp  #0
		beq  _zero
_positive	lda  #1
_zero		rts
_negative	lda  #-1
		rts
		.pend

func_sign_l_r14r15_into_A      .proc
    lda  cx16.r14+3              ; msb
    bmi  _negative
    bne  _positive
    lda  cx16.r14+2
    bne  _positive
    lda  cx16.r14+1
    bne  _positive
    lda  cx16.r14
    beq  _zero
    lda  #1
_zero
    rts
_negative
    lda  #-1
    rts
_positive
    lda  #1
    rts

.pend



func_sqrt16_into_A	.proc
		; integer square root
		; http://6502org.wikidot.com/software-math-sqrt
		; https://github.com/TobyLobster/sqrt_test/blob/main/sqrt/sqrt7.a
		; Tweaked by TobyLobster and 0xC0DE to be smaller and faster
_numl = P8ZP_SCRATCH_W1
_numh = P8ZP_SCRATCH_W1+1
_loop_counter = P8ZP_SCRATCH_REG
_root = P8ZP_SCRATCH_B1
            sta  _numl
            sty  _numh
            ldx  #$ff
            stx  _loop_counter
            inx
            stx  _root
            sec
_loop       lda  _numh
            sbc  #$40
            tay
            txa
            sbc  _root
            bcc  +
            sty  _numh
            bcs  ++
+           txa
+           rol  _root
            asl  _numl
            rol  _numh
            rol  a
            asl  _numl
            rol  _numh
            rol  a
            tax
            lsr  _loop_counter
            bne  _loop
            lda  _root
            rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
		.section BSS
_work1	.byte  ?
_work3	.word  ?
		.send BSS
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
		.section BSS
_work1	.byte  ?
_work3	.word  ?
		.send BSS
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peek   .proc
	; -- read the byte value on the address in AY, into A
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_peekw   .proc
	; -- read the word value on the address in AY, into AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend

func_peekl   .proc
	; -- read the ;pmg value on the address in AY, into R14:R15
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+1
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+2
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+3
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_pokew_scratchW2   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W2),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W2),y
	rts
	.pend

func_pokel   .proc
	; -- store the long value in R14:R15 in the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  cx16.r14
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+1
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+2
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+3
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_clamp_byte .proc
	; signed value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	tay
	sec
	sbc  P8ZP_SCRATCH_W1+1
	bvc  +
	eor  #$80
+       bmi  +
	lda  P8ZP_SCRATCH_W1+1
	tay
	jmp  ++
+       tya
+	sec
	sbc  P8ZP_SCRATCH_W1
	bvc  +
	eor  #$80
+       bmi  +
	tya
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend


func_clamp_ubyte .proc
	; value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	cmp  P8ZP_SCRATCH_W1+1
	bcc  +
	lda  P8ZP_SCRATCH_W1+1
+       cmp  P8ZP_SCRATCH_W1
	bcc  +
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_word .proc
	; signed value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_W2+1
	lda  P8ZP_SCRATCH_W2
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_uword .proc
	; value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	cpy  P8ZP_SCRATCH_W2+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W2
	bcc  ++
+       beq  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	cpy  P8ZP_SCRATCH_W1+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W1
	bcc  ++
+       beq  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts

	.pend
	.pend
; global float constants
prog8_float_const_0	.byte  $84, $20, $00, $00, $00  ; float 10.0
; struct types
; struct instances without initialization values, as BSS zeroed at startup
	.section BSS
prog8_struct_instances_bss  .block
	.endblock
	.send BSS
; struct instances with initialization values
	.section STRUCTINSTANCES
prog8_struct_instances  .block
	.endblock
	.send STRUCTINSTANCES
	.dsection STRUCTINSTANCES
; bss sections
PROG8_VARSHIGH_RAMBANK = 1
	.dsection BSS_NOCLEAR
prog8_bss_section_start
	.dsection BSS
prog8_bss_section_size = * - prog8_bss_section_start
	.dsection BSS_SLABS
prog8_program_end	; end of program label for progend()
	; memtop check
	.cerror * >= $9f00, "Program too long by ", * - $9eff, " bytes, memtop=$9f00"
